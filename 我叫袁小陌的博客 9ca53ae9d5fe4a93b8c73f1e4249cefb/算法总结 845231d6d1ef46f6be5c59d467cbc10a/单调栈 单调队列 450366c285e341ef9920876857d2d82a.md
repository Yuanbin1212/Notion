# 单调栈/单调队列

Last edited time: May 4, 2023 2:02 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: 算法

## 单调栈

**单调递增栈可以找到左起第一个比当前数字小的元素**

**单调递减栈可以找到左起第一个比当前数字大的元素**

![Untitled](%E5%8D%95%E8%B0%83%E6%A0%88%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%20450366c285e341ef9920876857d2d82a/Untitled.png)

## 队列

```cpp
push_front()：在容器头部添加一个元素
push_back()：在容器尾部添加一个元素
pop_front()：删除容器头部的元素
pop_back()：删除容器尾部的元素
front()：返回容器头部的元素
back()：返回容器尾部的元素
size()：返回容器中元素的数量
empty()：判断容器是否为空
clear()：清空容器中所有的元素
insert()：在指定位置插入一个或多个元素
erase()：删除指定位置的一个或多个元素
swap()：交换两个容器的元素
emplace_front()：在容器头部位置构造一个新元素
emplace_back()：在容器尾部位置构造一个新元素
at()：返回指定位置的元素
resize()：改变容器中元素的数量
assign()：用新元素替换原有元素
	void assign(size_type n, const value_type& val);
	void assign(InputIterator first, InputIterator last);
	void assign(initializer_list<value_type> il);
```

## 单调队列

单调队列是一种特殊的队列，它可以在 O(1) 的时间内完成如下操作：

1. 在队尾插入一个元素
2. 在队头删除一个元素
3. 在 O(1) 的时间内获取队列中的最大值或最小值

单调队列通常用于解决滑动窗口问题，即在一个大小为 k 的窗口中，找到最大或最小的元素。具体实现方法是维护一个单调递减或单调递增的队列，队列中的元素按照它们在原数组中的顺序排列。

在插入新元素时，我们从队列的队尾开始比较，将比新元素小的元素从队尾中删除，直到队尾元素大于等于新元素。这样可以保证队列中的元素仍然是单调递减或单调递增的。

在删除元素时，我们只需要判断队头元素是否过期（即是否在当前窗口内），如果过期则将其从队头中删除。

在获取最大或最小值时，我们只需要返回队头元素即可。

单调队列的时间复杂度为 O(n)，其中 n 是原数组的长度。

![https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif](https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif)

## 优先队列

priority_queue：优先队列，本质是堆实现。与队列不同的是，priority_queue只能访问队列头部的信息（使用top），且插入元素后，会自动排序。

```cpp
top(): 访问队头元素
empty(): 队列是否为空
size():返回队列内元素个数
push():插入元素到队尾 (并排序)
emplace():原地构造一个元素并插入队列
pop():弹出队头元素
swap():交换两个队列的内容   a.swap(b); 使用b.swap(a)效果一样

priority_queue<Type, Container, Functional>

Type:数据类型，就是优先队列中每一个元素的数据类型

Container:容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。
					STL里面默认用的是vector）【简单理解就是用什么容器实现这个优先级队列】

Functional:比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，
使用基本数据类型时，只需要传入数据类型，
默认是大顶堆【有greater、less和自定义函数，
其中greater使得优先队列中的元素升序排列，所以第一个元素（头部）就是最小的元素，也就是小顶堆；
less使得元素降序排列，那么第一个元素就是最大的，也就是大顶堆。】

以下是一些常用的函数对象:
less<T>：比较函数对象，用于判断T类型的元素是否小于另一个元素。
greater<T>：比较函数对象，用于判断T类型的元素是否大于另一个元素。
plus<T>：算术函数对象，用于计算两个T类型的元素之和。
minus<T>：算术函数对象，用于计算两个T类型的元素之差。
multiplies<T>：算术函数对象，用于计算两个T类型的元素之积。
divides<T>：算术函数对象，用于计算两个T类型的元素之商。
modulus<T>：算术函数对象，用于计算两个T类型的元素的余数。
如果要自定义更复杂的排序规则，可以使用Lambda表达式或重载比较运算符等方式来创建自己的函数对象。

如果你需要实现自定义的排序规则，可以通过创建一个函数对象（Functor）
并将其传递给priority_queue的构造函数来实现。
在这个函数对象中，我们需要重载圆括号运算符operator()，用于比较两个元素之间的优先级关系。
注意传入的可以是 函数指针或者 函数对象（类对操作符()进行了重载)

队列是:先进先出

STL默认都是使用()比较的，默认比较使用less（即'<'运算符），
如sort(a,a+n)，默认将数组按照递增的顺序来排序（前面的元素<后面的嘛），
但是优先队列的源码比较奇特，虽然按道理使用less比较应该默认是小根堆（即堆顶元素最小），
但是priority_queue<>默认是大根堆的，这是因为优先队列队首指向最后，队尾指向最前面的缘故！
每次入队元素进去经排序调整后，优先级最大的元素排在最前面，也就是队尾指向的位置，
这时候队首指向优先级最小的元素！所以虽然使用less但其实相当于greater，
我们重载运算符的时候比较函数里面写>就相当于<排序方式

重载方式
方式一：struct重载运算符()
struct cmp{
   bool operator()(vector<int>&a,vector<int>&b){
       return a[0]>b[0]; 
   }
};
priority_queue<vector<int>,vector<vector<int>>,cmp> q;//小顶堆

方式二：class重载运算符()
class cmp{
public:
    bool operator()(vector<int>&a,vector<int>&b){
        return a[0]>b[0]; 
    }
};
priority_queue<vector<int>,vector<vector<int>>,cmp> q;//小顶堆

方式三：定义函数
bool cmp(vector<int>&a,vector<int>&b){
	return a[0]>b[0];
}
decltype()是用于获得函数指针的 类型的。在模板中也要传入它们的类型。
decltype()要传入的是一个对象的地址，因此需要对cmp加取值符，&cmp为对象的地址
在这里插入图片描述
因此可以由函数地址cmp 转为函数指针类型 decltype(&cmp)
如果作为类成员函数，一定要声明static
priority_queue<vector<int>,vector<vector<int>>,decltype(&cmp)> q(cmp);//小顶堆

方式四：lambda表达式
auto cmp=[](vector<int>&a,vector<int>&b)->bool{
            return a[0]>b[0];
        };
priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)> q(cmp);//小顶堆

方式五：function包装lambda表达式

要加入头文件#include<functional>
由于function对lambda函数进行了包装 ,cmp本身就是一个对象地址。（function对象）
直接decltype(cmp)获得函数指针 的类型。
function<bool(vector<int>&,vector<int>&)> cmp=[](vector<int>&a,vector<int>&b)->bool{
            return a[0]>b[0];
        };
priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)> q(cmp);//小顶堆
```