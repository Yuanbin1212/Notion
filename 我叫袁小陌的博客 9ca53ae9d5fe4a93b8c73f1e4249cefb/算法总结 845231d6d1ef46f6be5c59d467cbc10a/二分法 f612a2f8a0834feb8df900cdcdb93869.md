# 二分法

Last edited time: May 4, 2023 2:03 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: 算法

1. **二分法前提**
    1. **数组为有序数组**
    2. **数组中无重复元素**
    

二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则

1. 两种写法
    
    1. 左闭右闭即[left, right]
    
- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

![Untitled](%E4%BA%8C%E5%88%86%E6%B3%95%20f612a2f8a0834feb8df900cdcdb93869/Untitled.png)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = ((right -left) // 2) + left
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid

        return -1
```

1. 左闭右开即[left, right)
- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

![Untitled](%E4%BA%8C%E5%88%86%E6%B3%95%20f612a2f8a0834feb8df900cdcdb93869/Untitled%201.png)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = ((right -left) // 2) + left
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        
        return -1
```

**循环不变量原则**

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 `n`，生成一个包含 `1`到 `n^2`所有元素，且元素按顺时针顺序螺旋排列的 `n x n`
 正方形矩阵 `matrix`。

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        result = [[0] * n  for j in range(n)]
        startx, starty = 0, 0
        loop = n // 2
        count = 1
        for offset in range(1, loop + 1):
            # 从左往右
            for i in range(starty, n - offset):
                result[startx][i] = count
                count += 1
            # 从右往下
            for i in range(startx, n - offset):
                result[i][n - offset] = count
                count += 1
            # 从右往左
            for i in range(n - offset, starty, -1):
                result[n - offset][i] = count
                count += 1
            # 从下往上
            for i in range(n - offset, startx, -1):
                result[i][starty] = count
                count += 1
            starty += 1
            startx += 1

        if n%2 != 0:
            result[n//2][n//2] = count
        return result
```