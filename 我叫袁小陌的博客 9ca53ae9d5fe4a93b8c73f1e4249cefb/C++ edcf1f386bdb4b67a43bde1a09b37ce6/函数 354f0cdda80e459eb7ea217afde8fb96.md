# 函数

Date: June 2, 2023
Last edited time: June 2, 2023 5:04 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: C++

## 函数重载

函数重载是指在同一个作用域内定义多个同名函数，但这些函数的参数类型、参数个数或参数顺序不同。在调用这些同名函数时，编译器会根据传入的参数类型、个数和顺序，自动选择最合适的函数进行调用。

函数重载的作用主要有两个：

1. 提高代码的可读性和可维护性：函数重载可以使代码更加简洁、易读、易懂，减少代码的重复性，同时也便于后期的维护和修改。
2. 增加程序的灵活性：函数重载可以根据不同的参数类型和个数，实现不同的功能，从而增加程序的灵活性和可扩展性。

函数重载的规则如下：

1. 函数名必须相同，参数列表必须不同（参数类型、参数个数或参数顺序不同）。
2. 返回值类型不能作为函数重载的区分标准。
3. 函数重载可以发生在同一个类中，也可以发生在不同的类中。
4. 函数重载不能仅仅通过参数的名称或参数的默认值来区分。
5. 在函数调用时，编译器会根据传入的参数类型、个数和顺序，自动选择最合适的函数进行调用。

例如，以下是一个简单的函数重载的例子：

```cpp
#include <iostream>

using namespace std;

int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int main() {
    cout << add(1, 2) << endl; // 调用第一个 add 函数
    cout << add(1.0, 2.0) << endl; // 调用第二个 add 函数
    return 0;
}

```

在上面的例子中，我们定义了两个同名的函数 `add`，一个是接受两个整型参数的函数，另一个是接受两个双精度浮点型参数的函数。在调用这两个函数时，编译器会根据传入的参数类型自动选择最合适的函数进行调用。

Function overload resolution（函数重载解析）是指编译器在调用一个重载函数时，根据实参的类型、个数和顺序来选择最合适的函数的过程。这个过程是由编译器在编译期间完成的，它会根据一定的规则来选择最合适的函数。

当有多个函数满足调用条件时，编译器会根据一定的规则来选择最合适的函数。如果没有找到最合适的函数，就会发生 ambiguous matches（二义性匹配）的情况。

ambiguous matches（二义性匹配）是指编译器在调用一个重载函数时，无法确定最合适的函数，因为有多个函数都满足调用条件。这种情况下，编译器就无法进行函数重载解析，会发生编译错误。

以下是一个函数重载解析和二义性匹配的例子：

```cpp
#include <iostream>

using namespace std;

void foo(int x) {
    cout << "foo(int x) is called." << endl;
}

void foo(double x) {
    cout << "foo(double x) is called." << endl;
}

int main() {
    foo(10); // 调用 foo(int x)
    foo(10.0); // 调用 foo(double x)
    foo('a'); // 调用 foo(int x)，因为字符常量 'a' 被隐式转换为 int 类型的 ASCII 码值 97
    foo(10L); // 编译错误，因为 long 类型的实参可以隐式转换为 int 或 double 类型，导致二义性匹配
    return 0;
}

```

在上面的例子中，我们定义了两个同名的函数 `foo`，一个是接受一个整型参数的函数，另一个是接受一个双精度浮点型参数的函数。在调用这两个函数时，编译器会根据传入的参数类型自动选择最合适的函数进行调用。当我们调用 `foo(10)` 和 `foo(10.0)` 时，编译器可以正确地选择最合适的函数。但是当我们调用 `foo('a')` 和 `foo(10L)` 时，就会发生二义性匹配的情况，因为字符常量 'a' 被隐式转换为 int 类型的 ASCII 码值 97，而 long 类型的实参可以隐式转换为 int 或 double 类型，导致编译器无法确定最合适的函数，从而发生编译错误。

## 函数模板

C++ 函数模板是一种通用的函数定义，它可以处理不同类型的数据。使用函数模板可以避免编写重复的代码，提高代码的复用性和可维护性。

下面是 C++ 函数模板的一些总结：

1. 函数模板的语法形式为：

```cpp
template <typename T>
返回值类型 函数名(T 参数) {
    // 函数体
}

```

其中，`typename T` 表示一个模板参数，可以是任意类型的数据。在函数定义中，可以使用模板参数 `T` 来定义函数的参数、返回值、局部变量等。

1. 函数模板的调用方式为：

```cpp
函数名<类型>(参数);

```

其中，`类型` 表示具体的数据类型，`参数` 表示函数的参数。在调用时，需要指定模板参数的具体类型。

1. 函数模板可以有多个模板参数，语法形式为：

```cpp
template <typename T1, typename T2, ...>
返回值类型 函数名(T1 参数1, T2 参数2, ...) {
    // 函数体
}

//c++20的新功能
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}

//等同于
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
```

在函数定义中，可以使用多个模板参数来处理不同类型的数据。

1. 函数模板可以和普通函数一起使用，如果模板函数和普通函数的函数名和参数列表完全相同，编译器会优先选择普通函数。
2. 函数模板可以重载，即可以定义多个模板函数，处理不同类型的数据。重载的模板函数必须在函数名和参数列表上有所区别，否则编译器会报错。
3. 函数模板可以有默认模板参数，语法形式为：

```cpp
template <typename T = int>
返回值类型 函数名(T 参数) {
    // 函数体
}
```

在函数定义中，可以为模板参数指定默认值，如果调用函数时没有指定模板参数，编译器会使用默认值。

## **非类型模板参数的用处**

截至 C++20，函数参数不能是 constexpr。对于普通函数、constexpr 函数（这是有道理的，因为它们必须能够在运行时运行）也是如此，也许令人惊讶的是，甚至是 consteval 函数也是如此

因此，假设我们有一些这样的函数：

```cpp
#include <cassert>
#include <cmath> // for std::sqrt
#include <iostream>

double getSqrt(double d)
{
    assert(d >= 0.0 && "getSqrt(): d must be non-negative");

    if (d >= 0)
        return std::sqrt(d);

    return 0.0;
}

int main()
{
    std::cout << getSqrt(5.0) << '\n';
    std::cout << getSqrt(-5.0) << '\n';

    return 0;
}
```

运行时，对 `getSqrt(-5.0)` 的调用将在运行时断言

但是，如果我们将函数参数更改为非类型模板参数

```cpp
#include <cmath> // for std::sqrt
#include <iostream>

template <double D> // requires C++20 for floating point non-type parameters
double getSqrt()
{
    static_assert(D >= 0.0, "getSqrt(): D must be non-negative");

    if constexpr (D >= 0) // ignore the constexpr here for this example
        return std::sqrt(D); // strangely, std::sqrt isn't a constexpr function

    return 0.0;
}

int main()
{
    std::cout << getSqrt<5.0>() << '\n';
    std::cout << getSqrt<-5.0>() << '\n';

    return 0;
}
```

 `getSqrt<-5.0>()` 会在编译时报错