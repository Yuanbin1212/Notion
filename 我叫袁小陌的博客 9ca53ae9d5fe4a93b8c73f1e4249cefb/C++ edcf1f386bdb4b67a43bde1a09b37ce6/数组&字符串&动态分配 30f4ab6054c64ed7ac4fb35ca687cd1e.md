# 数组&字符串&动态分配

Date: June 8, 2023
Last edited time: June 9, 2023 1:51 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: C++

## **`std::string_view` 参数比 `const std::string&` 更有效**

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view sv)
{
    std::cout << sv << '\n';
}

void printS(const std::string& s)
{
    std::cout << s << '\n';
}

int main()
{
    std::string s{ "Hello, world" };
    std::string_view sv { s };

    // Pass to `std::string_view` parameter
    printSV(s);              // ok: inexpensive conversion from std::string to std::string_view
    printSV(sv);             // ok: inexpensive copy of std::string_view
    printSV("Hello, world"); // ok: inexpensive conversion of C-style string literal to std::string_view

    // pass to `const std::string&` parameter
    printS(s);              // ok: inexpensive bind to std::string argument
    printS(sv);             // compile error: cannot implicit convert std::string_view to std::string
    printS(static_cast<std::string>(sv)); // bad: expensive creation of std::string temporary
    printS("Hello, world"); // bad: expensive creation of std::string temporary

    return 0;
}
```

## 如果被查看的字符串在**`std::string_view`**之前销毁，则访问 **`std::string_view`** 将导致未定义的行为

```cpp
#include <iostream>
#include <string>
#include <string_view>

std::string_view askForName()
{
  std::cout << "What's your name?\n";

  // Use a std::string, because std::cin needs to modify it.
  std::string name{};
  std::cin >> name;

  // We're switching to std::string_view for demonstrative purposes only.
  // If you already have a std::string, there's no reason to switch to
  // a std::string_view.
  std::string_view view{ name };

  std::cout << "Hello " << view << '\n';

  return view;
} // name dies, and so does the string that name created.

int main()
{
  std::string_view view{ askForName() };

  // view is observing a string that already died.
  std::cout << "Your name is " << view << '\n'; // Undefined behavior

  return 0;
}
```

## 防止悬空指针(dangling pointers)

```cpp
#include <iostream>

int main()
{
    int* ptr{ new int{} }; // dynamically allocate an integer
    int* otherPtr{ ptr }; // otherPtr is now pointed at that same memory location

    delete ptr; // return the memory to the operating system.  ptr and otherPtr are now dangling pointers.
    ptr = nullptr; // ptr is now a nullptr

    // however, otherPtr is still a dangling pointer!

    return 0;
}
```

## 内存泄漏

C++中内存泄漏的场景有以下几种，并且针对每一种场景，我都举例说明一下。

1. 忘记释放动态分配的内存

在程序中使用new动态分配内存时，必须在不再需要该内存块时使用delete释放，否则就会发生内存泄漏。例如下面的代码就会导致内存泄漏：

```cpp
void foo() {
  int* p = new int;
  // do something with p
  // forget to delete p
}

```

在这个例子中，一个指向整型变量的指针被动态分配，但没有在函数结束时释放。这将导致内存泄漏，因为操作系统无法回收未使用的内存。

1. 错误的使用new和delete

在使用new动态分配数组时，必须使用delete[]释放内存，而不是使用delete。例如下面的代码就会导致内存泄漏：

```cpp
void foo() {
  int* p = new int[10];
  // do something with p
  delete p; // should use delete[] instead
}

```

在这个例子中，一个指向整型数组的指针被动态分配，但是使用了delete而不是delete[]释放内存。这会导致内存泄漏，因为操作系统无法回收未使用的内存。

1. 在循环中动态分配内存，但没有在循环结束时释放所有的内存

在循环中使用new动态分配内存时，必须在循环结束时释放该内存块，否则就会发生内存泄漏。例如下面的代码就会导致内存泄漏：

```cpp
void foo() {
  for (int i = 0; i < 10; i++) {
    int* p = new int;
    // do something with p
    // forget to delete p
  }
}

```

在这个例子中，循环中动态分配了10个整型变量的内存，但没有在循环结束时释放它们。这将导致内存泄漏，因为操作系统无法回收未使用的内存。

1. 覆盖指向动态分配内存的指针，使其无法释放

如果一个指向动态分配内存的指针被覆盖，那么就会导致内存泄漏。例如下面的代码就会导致内存泄漏：

```cpp
void foo() {
  int* p = new int;
  p = new int; // p now points to a different memory block
  delete p; // can't delete the original memory block
}

```

在这个例子中，首先动态分配了一个整型变量的内存，然后又动态分配了一个整型变量的内存，并将指向第一个内存块的指针p覆盖为指向第二个内存块的指针。这将导致内存泄漏，因为指向第一个内存块的指针已经丢失，无法释放该内存块。