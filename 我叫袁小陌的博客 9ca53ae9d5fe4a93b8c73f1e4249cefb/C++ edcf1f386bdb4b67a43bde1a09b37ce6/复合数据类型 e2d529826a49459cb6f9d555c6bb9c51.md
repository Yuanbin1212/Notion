# 复合数据类型

Last edited time: June 9, 2023 1:50 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: C++

## const int*  && int* const  && const int* const 的区别

这三个声明都涉及到指针和const关键字，它们的具体含义如下：

1. `const int*`：这是一个指向const int类型的指针，也就是说，指针所指向的值是不能被修改的，但是指针本身是可以修改的。例如：

```cpp
const int value = 5;
const int* ptr = &value;

```

这里`ptr`是一个指向`value`的指针，但是`value`是一个const变量，因此不能通过`ptr`来修改`value`的值。

1. `int* const`：这是一个指向int类型的const指针，也就是说，指针本身是不能被修改的，但是指针所指向的值是可以被修改的。例如：

```cpp
int value = 5;
int* const ptr = &value;

```

这里`ptr`是一个指向`value`的const指针，也就是说，不能通过`ptr`来修改`ptr`本身的值，但是可以通过`ptr`来修改`value`的值。

1. `const int* const`：这是一个指向const int类型的const指针，也就是说，指针本身和指针所指向的值都是不能被修改的。例如：

```cpp
const int value = 5;
const int* const ptr = &value;

```

这里`ptr`是一个指向`value`的const指针，不能通过`ptr`来修改`ptr`本身的值，也不能通过`ptr`来修改`value`的值。

```cpp
#include <iostream>

int main() {
    int value = 5;
    const int* ptr1 = &value;
    int* const ptr2 = &value;
    const int* const ptr3 = &value;

    std::cout << "ptr1: " << *ptr1 << std::endl;
    std::cout << "ptr2: " << *ptr2 << std::endl;
    std::cout << "ptr3: " << *ptr3 << std::endl;

    // 尝试修改指针所指向的值
    // ptr1指向的值是const，不能修改
    // *ptr2 = 10;  // 编译错误，指针本身是const，不能修改
    // ptr3指向的值和指针本身都是const，不能修改

    // 尝试修改指针本身的值
    value = 10;
    // ptr1可以修改，因为指针本身不是const
    ptr1 = &value;
    // ptr2不能修改，因为指针本身是const
    // ptr2 = &value;  // 编译错误，指针本身是const，不能修改
    // ptr3不能修改，因为指针本身和指针所指向的值都是const
    // ptr3 = &value;  // 编译错误，指针本身和指针所指向的值都是const，不能修改

    std::cout << "ptr1: " << *ptr1 << std::endl;
    std::cout << "ptr2: " << *ptr2 << std::endl;
    std::cout << "ptr3: " << *ptr3 << std::endl;

    return 0;
}

/*
ptr1: 5
ptr2: 5
ptr3: 5
ptr1: 10
ptr2: 10
ptr3: 10
*/
```

## 类模板

```cpp
#include <iostream>

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

template <typename T>
constexpr T max(Pair<T> p)
{
    return (p.first < p.second ? p.second : p.first);
}

int main()
{
    Pair<int> p1{ 5, 6 };
    std::cout << max<int>(p1) << " is larger\n"; // explicit call to max<int>

    Pair<double> p2{ 1.2, 3.4 };
    std::cout << max(p2) << " is larger\n"; // call to max<double> using template argument deduction (prefer this)

    return 0;
}
```

用`std::pair` 替代

```cpp
#include <iostream>
#include <utility>

template <typename T, typename U>
void print(std::pair<T, U> p)
{
    std::cout << '[' << p.first << ", " << p.second << ']';
}

int main()
{
    std::pair<int, double> p1{ 1, 2.3 }; // a pair holding an int and a double
    std::pair<double, int> p2{ 4.5, 6 }; // a pair holding a double and an int
    std::pair<int, int> p3{ 7, 8 };      // a pair holding two ints

    print(p2);

    return 0;
}
```

## `array` 作为函数入参传入

```cpp
#include <iostream>

void printSize(int array[])
{
    std::cout << "函数入参array的类型 " << typeid(array).name() << " 它的size是 " << sizeof(array) << '\n';
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
}

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << "变量array的类型 " << typeid(array).name() << " 它的size是 " << sizeof(array) << '\n';
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
    printSize(array);

    return 0;
}

/*
变量array的类型 int [8] 它的size是 32
8
函数入参array的类型 int * __ptr64 它的size是 8
2
*/
```