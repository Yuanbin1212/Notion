# String

Last edited time: May 4, 2023 2:22 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: C++

## ****string类对象构造****

```cpp
string()//构造空字符串
string(const char* s);//拷贝s所指向的字符串序列
string(const char* s, size_t n);//拷贝s所指向的字符串序列的第n个到结尾的字符
string(size_t n, char c);//将字符c复制n次
string(const string& str);//拷贝构造函数
//拷贝s中从pos位置起的len个字符，若npos>字符串长度，就拷贝到字符串结尾结束
string(const string& str, size_t pos, size_t len = npos);

#include <iostream>
#include <string>
using namespace std;
 
int main()
{
	string s0 = "Hello World";
	string s1(); //构造空字符串
	string s2("good start");
	string s3(s0,1);//拷贝s0所指向的字符串序列的第1个到结尾的字符
	string s4(5, 'h');//将字符'h'复制5次
	string s5(s0);//用s0拷贝构造s5
	string s6(s0,2,30);//拷贝s0中从第2个位置起的30个字符，拷贝到字符串结尾就结束了
 
	cout << "s2:" << s2 << endl;
	cout << "s3:" << s3 << endl;
	cout << "s4:" << s4 << endl;
	cout << "s5:" << s5 << endl;
	cout << "s6:" << s6 << endl;
	
	return 0;
}
```

## ****string元素访问符****

```cpp
char& operator[] (size_t pos);//返回pos位置字符的引用，字符串可读可写，[]重载了operator[]
reference at(size_type pos);//同char& operator[]，返回pos位置字符的引用，字符串可读可写

#include <iostream>
#include <string>
using namespace std;
 
int main()
{
	string s0 = "Hello World";
    
   for (size_t i = 0; i < s0.size(); i++)
	{
		s0[i] = 'x';//使用operator[]访问字符串元素
		cout << s0[i];
	}
	cout << endl;
 
	for (size_t i = 0; i < s0.size(); i++)
	{
		s0.at(i) = 'y';//使用at访问字符串元素
		cout << s0[i];
	}
	cout << endl;
 
  return 0;
}

//输出
xxxxxxxxxxx
yyyyyyyyyyy
```

## ****string迭代器****

```cpp
iterator begin(); //返回指向字符串第一个字符的迭代器
iterator end(); //返回指向字符串最后一个字符的下一个位置的迭代器
reverse_iterator rbegin(); //返回字符串最后一个字符的反向迭代器
reverse_iterator rend(); //返回指向字符串第一个字符之前的反向迭代器

# begin和end是正向迭代器，rbegin和rend是反向迭代器

#include <iostream>
#include <string>
using namespace std;
 
int main()
{
	//正向迭代器
	string s0 = "Hello World";
	cout << s0 << endl;
 
	string::iterator it = s0.begin();
	char ch0 = 'a';
 
	while (it != s0.end())
	{
		*it = ch0;
		ch0++;
		cout << *it;
		it++;
	}
	cout << endl;
 
	//反向迭代器
	string s1("1234567890");
	cout << s1 << endl;
	string::reverse_iterator rit = s1.rbegin();
	char ch1 = 'a';
 
	while (rit != s1.rend())
	{
     //从右向左依次赋值
		*rit = ch1;
		ch1++;
		cout << *rit;
		rit++;
	}
	cout << endl;
	cout << s1 << endl;
	return 0;
}

//输出
Hello World
abcdefghijk
1234567890
abcdefghij
jihgfedcba

```

## 遍历

```cpp
// 范围for也可以实现遍历：依次取容器中的数据赋值给e，自动判断结束
for(auto& e:s){}
```

## ****string插入和拼接****

### ****string插入****

```cpp
1. 在字符串末尾插入
void push_back (char c);  //向字符串末尾追加一个字符

2. 在指定位置插入
string& insert(size_t pos, const string& str);//插入字符串拷贝
string& insert (size_t pos, const char* s);//插入c形式的字符串
string& insert (size_t pos, const char* s, size_t n);//将字符串s的前n个字符插到pos位置

#include<iostream>
#include<string>
using namespace std;
int main()
{
	string s0("");
	s0.push_back('h');//s0尾插h
	cout << s0 << endl;
 
	string s1("ell");
	s0.insert(1, s1);//在下标为1的位置插入s1的拷贝
	cout << s0 << endl;
 
	s0.insert(4, "o");//在下标为4的位置插入字符串o
	cout << s0 << endl;
 
   s0.insert(0, "cplusplus",2);//在下标为0的位置插入"cplusplus"的前2个字符
   cout << s0 << endl;
 
   return 0;
}

//输出
h
hell
hello
cphello
```

### ****string拼接****

```cpp
1. 使用append进行拼接
string& append (const string& str);  //向字符串对象末尾追加字符串
string& append (const char* s);//向字符串末尾追加字符
string& append(size_t n, char c);//向字符串末尾追加n个相同字符

#include<iostream>
#include<string>
using namespace std;
int main()
{
	string s0("");
	s0.append("hello");//将hello追加到s0末尾
	cout << s0 << endl;
	string s1 = " world";
	s0.append(s1);//s0.append(s1.begin().s1.end());//将字符串s1追加到s0末尾
	cout << s0 << endl;
	s0.append(3, '!');//想s0末尾追加3个！
	cout << s0 << endl;
	
	//用+=追加很方便,比append更常用
	s0 += '!';
	s0 += " yes";
	string s2 = " it is.";
	s0 += s2;
	cout << s0 << endl;
}

//输出
hello
hello world
hello world!!!
hello world!!!! yes it is.

2. 使用全局函数operator+拼接
string operator+ (const string& lhs, const string& rhs);//拼接lhs和rhs

#include<iostream>
#include<string>
using namespace std;
 
int main()
{    
    string s1 = "cplusplus";
	string s2 = ".com";
	string s3 = s1 + s2;
	cout << s3 << endl;
 
	return 0;
}

//输出
cplusplus.com

```

## ****string删除****

```cpp
//从第pos个位置开始删除len个字符，pos缺省为0
string& erase (size_t pos = 0, size_t len = npos);

#include<iostream>
#include<string>
using namespace std;
 
int main()
{
  string s0 = "cplusplus.com";
	s0.erase(2, 2);
	cout << s0 << endl;
	s0.erase(2, 100);//len超过字符串长度也不会报错，npos为-1，转换成无符号数为4294967295，100远远小于这个数，因此不会报错
	cout << s0 << endl;
 
	unsigned int a = - 1;
	printf("%u", a);
 
    return 0;
}

//输出
cpsplus.com
cp
4294967295
```

## ****string容量****

```cpp
1. 求字符串个数
size_t size() const;//size()求字符串中有效字符的个数
size_t length() const;//length()求字符串中有效字符的个数

#include<iostream>
#include<string>
using namespace std;
 
int main()
{
    string s1;
	cout << s1.size() << endl;
	cout << s1.length() << endl;
    
    return 0;
}
// 0  0

2. 判空
bool empty() const;//判断字符串是否为空

3. 容量
size_t capacity() const;//返回所分配内存的字节数

string s1("cplusplus.com");
cout << s1.size() << endl;      // 13
cout << s1.capacity() << endl;  // 15

capcity( )比size( )大，要给'\0'留空间

3. 调整字符串大小
//将字符串大小调整为n个字符的长度，默认插入字符'\0',
//32位机器一般为4的倍数，64位机器一般为8的倍数，一般按2倍去调整
void resize (size_t n);
	
string s1("cplusplus.com");
s1.resize(20);
cout << s1.size() << endl;     // 20
cout << s1.capacity() << endl; // 30

4. 调整字符串容量
void reserve (size_t n = 0);//调整容量，缺省容量为0

string s1("cplusplus.com");
 
s1.reserve(20);
cout << "size:" << s1.size() << endl;
cout << "capacity" << s1.capacity() << endl;

s1.reserve(50);
cout << "size:" << s1.size() << endl;
cout << "capacity" << s1.capacity() << endl;

//输出
size:13
capacity30
size:13
capacity60
```

## ****string字符串操作****

```cpp
1. 获取c形式字符串
const char* c_str() const;//将 const string* 类型 转化为 const char* 类型

#include<iostream>
#include<string>
using namespace std;
 
int main()
{
	string s1("cplusplus");
	
	s1.resize(30);
	s1 += "!!!";
 
	string s2 = s1.c_str();
 
  cout <<"s1是"<< s1 << "，并且size 是" <<s1.size() << endl;
	cout <<"s2是"<< s2 << "，并且size 是" <<s2.size() << endl;
 
	return 0;
}

//输出
s1是cplusplus!!!，并且size 是33
s2是cplusplus，并且size 是9    //s1的c形式字符串，遇到第一个'\0'就截止了：

```

![Untitled](String%2068079cfbe45c4e32a9d667a15092a54b/Untitled.png)

```cpp

2. 查找
//返回在给定字符串中查找字符串str第一次出现的位置	
size_t find(const string & str, size_t pos = 0) const;
//返回在给定字符串中从下标为pos的位置开始查找字符串s第一次出现的位置
size_t find(const char* s, size_t pos = 0) const;
//返回在给定字符串中从下标为pos的位置开始查找字符串s的前n个字符第一次出现的位置
size_t find(const char* s, size_t pos, size_t n) const;
//返回在给定字符串中从下标为pos的位置开始查找字符c第一次出现的位置
size_t find(char c, size_t pos = 0) const;

#include<iostream>
#include<string>
using namespace std;
 
int main()
{
	string s1("cplusplus.co");
 
  //返回在s1中查找字符串"lu"第一次出现的位置
	cout << s1.find("lu") << endl;
	//返回在s1中从下标为3的位置开始查找字符串"lu"第一次出现的位置
	cout << s1.find("lu", 3) << endl;
	//返回在s1中从下标为3的位置开始查找字符"."第一次出现的位置
	cout << s1.find('.', 3) << endl;
	//返回在s1中从下标为3的位置开始查找字符串"com"的前2个字符第一次出现的位置
	cout << s1.find("com", 3, 2) << endl;
 
    
  cout << "取出文件名的后缀" << endl;
	string filename = "main.cpp";
	size_t pos = filename.find('.');
 
	if (pos != string::npos)
	{
		string buff(filename, pos);   //通过filename 构造一个String对象
		cout << buff << endl;
	}
	
	return 0;
}

//输出
2
6
9
10
取出文件名的后缀
.cpp

3. 查找子串
//截取给定字符串中从第pos个位置开始的len个长度的字符
string substr (size_t pos = 0, size_t len = npos) const;

#include<iostream>
#include<string>
using namespace std;
 
//获取域名
string getDomain(const string& url)
{
	size_t pos = url.find("://");
	if (pos != string::npos)
	{
		size_t start = pos + 3;
		size_t end = url.find('/', start);
		if (end != string::npos)
		{
			return url.substr(start, end-start);
		}
		else
		{
			return string();//返回一个匿名对象
		}
	}
	else
	{
		return string();
	}
}
 
//获取协议名
string getProtocal(const string& url)
{
	size_t pos = url.find("://");
	if (pos != string::npos)
	{
		return url.substr(0, pos);
	}
	else
	{
		return string();
	}
}
 
int main()
{
 
	//获取URL中的域名和协议名
	string url1 = "https://cplusplus.com/reference/string/string/rfind/";
	cout << getProtocal(url1) << endl;
	cout << getDomain(url1) << endl;
	
	string url2 = "https://www.baidu.com/";
	cout << getProtocal(url2) << endl;
	cout << getDomain(url2) << endl;
 
	return 0;
}

//输出
https
cplusplus.com
https
www.baidu.com

4. 反向查找
//从右向左在给定字符串中查找字符串str第一次出现的位置	
size_t rfind(const string & str, size_t pos = npos) const;
//从右向左在给定字符串中下标为pos的位置开始查找字符串s第一次出现的位置
size_t rfind(const char* s, size_t pos = npos) const;
//从右向左在给定字符串中从下标为pos的位置开始查找字符串s的前n个字符第一次出现的位置
size_t rfind(const char* s, size_t pos, size_t n) const;
//从右向左在给定字符串中从下标为pos的位置开始查找字符c第一次出现的位置
size_t rfind(char c, size_t pos = npos) const;

#include<iostream>
#include<string>
using namespace std;
 
int main()
{
    string url1 = "https://cplusplus.com/reference/string/string/rfind/";
    string url2 = "https://cplusplus.com/reference/string/string/rfind:/";
	cout << ":第一次出现的索引为 " <<url1.rfind(':') << endl;
	cout << ":第一次出现的索引为 " <<url2.rfind(':') << endl;
 
    return 0;
}

//输出
:第一次出现的索引为 5
:第一次出现的索引为 51

5. string字符串比较
bool operator== (const string& lhs, const string& rhs);
bool operator== (const char* lhs, const string& rhs);
bool operator== (const string& lhs, const char* rhs);
 
bool operator!= (const string& lhs, const string& rhs);
bool operator!= (const char* lhs, const string& rhs);
bool operator!= (const string& lhs, const char* rhs);
 
bool operator<  (const string& lhs, const string& rhs);
bool operator<  (const char* lhs, const string& rhs);
bool operator<  (const string& lhs, const char* rhs);
 
bool operator<= (const string& lhs, const string& rhs);
bool operator<= (const char* lhs, const string& rhs);
bool operator<= (const string& lhs, const char* rhs);
 
bool operator>  (const string& lhs, const string& rhs);
bool operator>  (const char* lhs, const string& rhs);
bool operator>  (const string& lhs, const char* rhs);
 
bool operator>= (const string& lhs, const string& rhs);
bool operator>= (const char* lhs, const string& rhs);
bool operator>= (const string& lhs, const char* rhs);

#include<iostream>
#include<string>
using namespace std; 
 
int main()
{
    string s1 = "cplusplus";
	string s2 = ".com";
	
	cout << (s1 == s2) << endl;
	cout << (s1 == "cplusplus.com") << endl;
	cout << ("cplusplus.com" == s2) << endl;
 
	return 0;
}

// 0 0 0
```

## C++中的string类与相关的接口

```cpp
//栈
push_back()：向字符串末尾添加一个字符，类似于栈的push操作。
pop_back()：删除字符串末尾的一个字符，类似于栈的pop操作。
back()：返回字符串末尾的字符，类似于栈的top操作。
size()：返回字符串中字符的个数，类似于栈的size操作。
empty()：判断字符串是否为空，类似于栈的empty操作。
```

## c++string栈的应用

1. 表达式求值：将中缀表达式转换为后缀表达式，然后使用栈来求值。
2. 括号匹配：使用栈来判断括号是否匹配。
3. 回文判断：将字符串压入栈中，然后再弹出来和原字符串进行比较，如果相同则为回文。
4. 十进制转二进制：使用栈来存储二进制位，每次将十进制数除以2，将余数压入栈中，最后依次弹出栈中的数即可得到二进制数。
5. 十进制转八进制或十六进制：类似于十进制转二进制，只需要将除以8或16即可。
6. 单词反转：将单词按照空格分割，然后将每个单词压入栈中，最后依次弹出栈中的单词即可得到反转后的字符串。
7. 记录操作历史：将每次操作压入栈中，可以用于撤销操作。
8. 实现递归：递归函数可以通过栈来实现，每次递归时将参数和返回地址压入栈中，递归结束后依次弹出栈中的参数和返回地址即可。

```cpp
// c++string的back相关接口包括：

back()：返回字符串的最后一个字符。

front()：返回字符串的第一个字符。

push_back(char c)：在字符串的末尾添加一个字符。

pop_back()：删除字符串的最后一个字符。

// C++中的string类提供了多种方法来弹出第一个字符，以下是其中的几种：

//使用erase函数：
string str = "hello";
str.erase(0, 1); //从第0个位置开始删除1个字符
cout << str << endl; //输出"ello"

//使用substr函数：
string str = "hello";
str = str.substr(1); //从第1个位置开始截取到末尾
cout << str << endl; //输出"ello"

//使用迭代器：
string str = "hello";
str.erase(str.begin()); //删除第一个字符
cout << str << endl; //输出"ello"

//使用下标操作符：
string str = "hello";
str = str.substr(1, str.length() - 1); //从第1个位置开始截取到末尾
cout << str << endl; //输出"ello"

//注意：以上方法都会改变原始字符串，如果需要保留原始字符串，可以使用副本或临时变量。
```