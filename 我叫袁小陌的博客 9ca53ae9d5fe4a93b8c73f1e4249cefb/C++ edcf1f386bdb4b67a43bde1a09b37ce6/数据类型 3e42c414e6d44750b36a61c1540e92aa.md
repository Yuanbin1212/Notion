# 数据类型

Last edited time: May 29, 2023 5:35 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: C++

| Types | Category | Meaning | Example |
| --- | --- | --- | --- |
| float
double
long double | Floating Point | a number with a fractional part | 3.14159 |
| bool | Integral (Boolean) | true or false | true |
| char
wchar_t
char8_t (C++20)
char16_t (C++11)
char32_t (C++11) | Integral (Character) | a single character of text | ‘c’ |
| short
int
long
long long (C++11) | Integral (Integer) | positive and negative whole numbers, including 0 | 64 |
| std::nullptr_t (C++11) | Null Pointer | a null pointer | nullptr |
| void | Void | no type | n/a |

## 整数

### 有符号整数范围

| Size/Type | Range |
| --- | --- |
| 8 bit signed | -128 to 127 |
| 16 bit signed | -32,768 to 32,767 |
| 32 bit signed | -2,147,483,648 to 2,147,483,647  |
| 64 bit signed | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |

### 无符号整数范围

| Size/Type | Range |
| --- | --- |
| 8 bit unsigned  | 0 to 255 |
| 16 bit unsigned | 0 to 65,535 |
| 32 bit unsigned | 0 to 4,294,967,295 |
| 64 bit unsigned | 0 to 18,446,744,073,709,551,615 |

## 数据溢出

在C++中，可以使用流输出运算符将有符号整型和无符号整型数据输出到控制台。当输出的数据超出了其类型所能表示的范围时，会发生溢出。

以下是一些示例代码：

```cpp
#include <iostream>
#include <limits>

int main() {
    // 有符号整形
    int signedInt = std::numeric_limits<int>::max();
    std::cout << "Signed integer: " << signedInt << std::endl; // 输出正常值
    signedInt++;
    std::cout << "Signed integer after overflow: " << signedInt << std::endl; // 输出溢出后的值

    // 无符号整形
    unsigned int unsignedInt = std::numeric_limits<unsigned int>::max();
    std::cout << "Unsigned integer: " << unsignedInt << std::endl; // 输出正常值
    unsignedInt++;
    std::cout << "Unsigned integer after overflow: " << unsignedInt << std::endl; // 输出溢出后的值

    return 0;
}
```

在上面的示例代码中，我们定义了一个有符号整数和一个无符号整数，并将它们初始化为其类型所能表示的最大值。然后分别对它们进行自增操作，以导致溢出。

在输出有符号整数的溢出值时，程序不会抛出异常或警告，而是输出一个负数。这是因为 C++ 中的有符号整数采用了二进制补码表示法，当发生溢出时，会将超出范围的位数舍去，而剩余的位数仍然按照补码表示法计算。因此，最终输出的值会是一个负数。

在输出无符号整数的溢出值时，程序也不会抛出异常或警告，而是输出一个很小的正数。这是因为 C++ 中的无符号整数采用了二进制原码表示法，当发生溢出时，会将超出范围的位数舍去，而剩余的位数仍然按照原码表示法计算。因此，最终输出的值会是一个很小的正数。

**Fixed-width integers 固定宽度整数**

| Name | Type | Range | Notes |
| --- | --- | --- | --- |
| std::int8_t | 1 byte signed | -128 to 127 | Treated like a signed char on many systems.  |
| std::uint8_t | 1 byte unsigned | 0 to 255 | Treated like an unsigned char on many systems.  |
| std::int16_t | 2 byte signed | -32,768 to 32,767 |  |
| std::uint16_t | 2 byte unsigned | 0 to 65,535 |  |
| std::int32_t | 4 byte signed | -2,147,483,648 to 2,147,483,647 |  |
| std::uint32_t | 4 byte unsigned | 0 to 4,294,967,295 |  |
| std::int64_t | 8 byte signed | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |  |
| std::uint64_t | 8 byte unsigned | 0 to 18,446,744,073,709,551,615 |  |

## 如何选择数据类型

- Prefer `int`
    
    when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
    
    当整数的大小无关紧要时，首选 `int` （例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 到 10 计数，则 int 是 16 位还是 32 位并不重要（数字适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况。
    
- Prefer `std::int#_t`
    
    when storing a quantity that needs a guaranteed range.
    
    存储需要保证范围的数量时，首选 `std::int#_t` 。
    
- Prefer `std::uint#_t`
    
    when doing bit manipulation or where well-defined wrap-around behavior is required.
    
    在执行位操作或需要明确定义的环绕行为时，首选 `std::uint#_t` 。
    

## size_t

`size_t` 是 C / C++ 语言中的一个数据类型，通常被用来存储对象的大小（以字节为单位）。这个类型在许多标准库函数和操作系统接口函数中被广泛使用，特别是与内存分配、字符串处理和数组索引相关的函数。

`size_t` 的作用主要有以下几个方面：

1. 内存分配：在动态内存分配中，例如 malloc() 函数，它通常返回指向新分配的内存块的指针，并将其大小存储在 `size_t` 类型的变量中。
2. 字符串处理：在字符串处理函数中，例如 strlen() 和 memcpy() 等函数， `size_t` 类型通常被用于表示字符串长度或复制的字节数等。
3. 数组索引：在数组索引中， `size_t` 类型通常被用于表示数组的下标，因为 `size_t` 能够容纳任何数组的大小。

总之， `size_t` 在编写不同平台，可移植性好的代码的时候很有用。它可以确保代码能够在不同的编译器和操作系统上运行，并且可以容纳大部分可能出现的内存大小和数组索引。

**Floating point numbers  浮点数**

| Category | Type | Minimum Size | Typical Size |
| --- | --- | --- | --- |
| floating point | float | 4 bytes | 4 bytes |
|  | double | 8 bytes | 8 bytes |
|  | long double | 8 bytes | 8, 12, or 16 bytes |

## 转义序列

| Name | Symbol | Meaning |
| --- | --- | --- |
| Alert | \a | Makes an alert, such as a beep 
警报，例如发出哔哔声 |
| Backspace | \b | Moves the cursor back one space
将光标向后移动一个空格 |
| Formfeed | \f | Moves the cursor to next logical page
将光标移动到下一个逻辑页 |
| Newline | \n | Moves cursor to next line 
将光标移动到下一行 |
| Carriage return | \r | Moves cursor to beginning of line
将光标移动到行首 |
| Horizontal tab | \t | Prints a horizontal tab
打印水平制表符 |
| Vertical tab | \v | Prints a vertical tab
打印垂直制表符 |
| Single quote | \’ | Prints a single quote
打印单引号 |
| Double quote | \” | Prints a double quote
打印双引号 |
| Backslash | \\ | Prints a backslash. 
打印反斜杠。 |
| Question mark | \? | Prints a question mark. 
打印问号 |
| Octal number | \(number) | Translates into char represented by octal
翻译成由八进制表示的字符 |
| Hex number | \x(number) | Translates into char represented by hex number
转换为由十六进制数表示的字符 |

## **std::int8_t 和 std::uint8_t 的行为可能像字符而不是整数**

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myint{65}; // initialize myint with value 65
    std::cout << myint << '\n';   // you're probably expecting this to print 65
    std::cout << static_cast<int>(myint) << '\n'; // will always print 65

    std::cout << "Enter a number between 0 and 127: ";
    std::int8_t myint2{};
    std::cin >> myint2;

    std::cout << "You entered: " << static_cast<int>(myint2) << '\n';

    return 0;
}
/*
A
65
Enter a number between 0 and 127: 35
You entered: 51
*/
```

当 `std::int8_t` 被视为字符时，输入例程将我们的输入解释为字符序列，而不是整数。所以当我们输入 `35` 时，我们实际上是在输入两个字符， `'3'` 和 `'5'` 。由于 char 对象只能包含一个字符，因此将提取 `'3'` （ `'5'` 保留在输入流中，以便以后可能提取）。因为字符 `'3'` 具有 ASCII 码位 51，所以值 `51` 存储在 `myint2` 中。

## Literal

| Literal value | Examples | Default literal type 默认文本类型 |
| --- | --- | --- |
| integer value | 5, 0, -3 | int |
| boolean value | true, false | bool |
| floating point value 浮点值 | 1.2, 0.0, 3.4 | double (not float!) 双（不浮动！ |
| character | ‘a’, ‘\n’ “a”、“\n” | char |
| C-style string | “Hello, world!” “你好，世界！” | const char[14] |

### **Literal suffixes**

| Data type | Suffix | Meaning |
| --- | --- | --- |
| integral | u or U u 或 U | unsigned int |
| integral | l or L l 或 L | long |
| integral | ul, uL, Ul, UL, lu, lU, Lu, or LUul， uL， Ul， UL， lu， lU， lu， or LU | unsigned long |
| integral | ll or LL LL或LL在 | long long |
| integral | ull, uLL, Ull, ULL, llu, llU, LLu, or LLUwool， uLL， Wool， ULL， llu， llU， LLu， or LLU | unsigned long long 无符号长长 |
| integral | z or Z Z 或 Z | The signed version of std::size_t (C++23)标准：：size_t （C++23） 的签名版本 |
| integral | uz or UZ 至 或 至 | std::size_t (C++23) 标准：：size_t （C++23） |
| floating point | f or F f 或 F | float |
| floating point | l or L l 或 L | long double |
| string | s | std::string |
| string | sv | std::string_view |

## 进制转换

C++ 支持四种数字表示方式：十进制、二进制、八进制和十六进制。在编程中，可以根据需求选择不同的数字表示方式。

下面是 C++ 中数字表示方式的总结：

- 十进制表示方式：默认的数字表示方式，使用 0-9 数字表示整数。
- 二进制表示方式：使用 0 和 1 表示整数。在 C++11 中，可以使用前缀 0b 或 0B 来表示一个二进制数字。
- 八进制表示方式：使用 0-7 数字表示整数。在 C++ 中，可以使用前缀 0 来表示一个八进制数字。
- 十六进制表示方式：使用 0-9 和 a-f/A-F 字母表示整数。在 C++ 中，可以使用前缀 0x 或 0X 来表示一个十六进制数字。

数字之间的转换可以使用以下方法：

- 将十进制数转换为其他进制数时，可以使用整除法和取余数的方法，将整数除以目标进制，并将余数倒序排列得到结果。
- 将其他进制数转换为十进制数时，可以使用加权法和幂的方法，将每一位上的数字乘以对应的权重后相加得到结果。
- 可以使用 std::bitset、std::hex、std::oct 等类型来表示二进制、十六进制和八进制数字。
- 可以使用 std::stoi、std::stol、std::stoul、std::stoll、std::stoull 等函数将字符串转换为整数类型。

需要注意的是，在不同进制之间进行转换时，需要保证数字格式的正确性，并且注意数据溢出的问题。在程序中应当遵循编码规范和最佳实践，使用适当的标识符和函数来处理数字的转换。

这些函数是 C++ 提供的用于将字符串转换为整型数字的函数，使用方法如下：

- std::stoi：将字符串转换为 int 类型数字。函数原型如下：

```cpp
int stoi(const string& str, size_t* pos = 0, int base = 10);
```

str 是要转换的字符串；pos 是一个可选参数，指向一个未转换部分的位置；base 是进制数，默认为 10。
示例：

```cpp
string str = "12345";
int num = std::stoi(str); // 将字符串 "12345" 转换为 int 类型数字
cout << "num: " << num << endl; // 输出结果为 num: 12345
```

- std::stol：将字符串转换为 long 类型数字。函数原型如下：

```cpp
long stol(const string& str, size_t* pos = 0, int base = 10);
```

其他与 std::stoi 相同。

- std::stoul：将字符串转换为 unsigned long 类型数字。函数原型如下：

```cpp
unsigned long stoul(const string& str, size_t* pos = 0, int base = 10);
```

其他与 std::stoi 相同。

- std::stoll：将字符串转换为 long long 类型数字。函数原型如下：

```cpp
long long stoll(const string& str, size_t* pos = 0, int base = 10);
```

其他与 std::stoi 相同。

- std::stoull：将字符串转换为 unsigned long long 类型数字。函数原型如下：

```cpp
unsigned long long stoull(const string& str, size_t* pos = 0, int base = 10);
```

其他与 std::stoi 相同。

这些函数可以将字符串表示的数字转换为对应的整型数字类型，当字符串格式不符合要求时会抛出异常。在使用这些函数时，需要注意输入的字符串必须是合法的数字格式，否则会导致程序出错。

## 常量的定义

1. #define 宏常量   #define 常量名 常量值
    - 通常在文件上方定义，表示一个常量
2. const修饰的变量  const 数据类型 常量名 = 常量值
    - 通常变量定义前加关键字const， 修饰该变量为常量，不可修改

## 类型转换

```cpp
long long stoll (const string& str, size_t* idx = 0, int base = 10);

其中，参数str表示要转换的字符串，
参数idx表示转换后第一个未能转换的字符的位置（如果没有未能转换的字符，则为0），
参数base表示转换的进制，默认为10。

strtol() 函数：将字符串转换为长整型数值，并返回其结果。

strtoull() 函数：将字符串转换为无符号长整型数值，并返回其结果。

int atoi(const char *nptr) 函数：将字符串转换为整型数值，并返回其结果。

atof() 函数：将字符串转换为双精度浮点数值，并返回其结果。

sscanf() 函数：从字符串中读取格式化输入，并将结果存储在指定的变量中。
```

## string_view和string的区别

`string_view` 和 `string` 都是 C++ 标准库中的字符串类型，但它们之间有一些区别。

`string` 是一种可变长度的字符串类型，可以在字符串中添加、插入、删除或修改字符。使用 `string` 类型的字符串通常更加灵活，适用于需要频繁进行字符串操作的场景。例如：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "hello";
    str += ", world!"; // 在字符串末尾添加 ", world!"
    std::cout << str << std::endl; // 输出 "hello, world!"

    return 0;
}

```

相反，`string_view` 是一种不可变的字符串类型，通常用于接受和传递字符串参数，而不需要对其进行修改的情况。使用 `string_view` 可以避免在复制字符串时产生额外的内存开销，因为它只是一个指向原始字符串的指针和一个表示字符串长度的整数。例如：

```cpp
#include <iostream>
#include <string_view>

void print(std::string_view str) {
    std::cout << str << std::endl;
}

int main() {
    std::string str = "hello, world!";
    print(str); // 将 string 转换为 string_view 并传递给函数

    return 0;
}
```

总之，如果您需要在程序中频繁地对字符串进行修改，请使用 `string`；如果您只需要接受和传递字符串参数并且不需要修改它们，请使用 `string_view`。

## 浮点数的比较

```cpp
//版本1
#include <algorithm> // std::max
#include <cmath> // std::abs

// return true if the difference between a and b is within epsilon percent of 
// the larger of a and b
bool approximatelyEqualRel(double a, double b, double relEpsilon)
{
    return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

//版本2
// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)
{
    // Check if the numbers are really close -- needed when comparing numbers near zero.
    double diff{ std::abs(a - b) };
    if (diff <= absEpsilon)
        return true;

    // Otherwise fall back to Knuth's algorithm
    return (diff <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}
```