# 函数

Last edited time: May 4, 2023 2:00 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: Python

1. 什么是函数
    1. 函数就相当于具备某一功能的工具
    2. 函数的使用必须遵循一个原则：
        1. 先定义
        2. 后调用
        
2. 为何要用函数
    1. 组织结构不清晰，可读性差
    2. 代码冗余
    3. 可维护性、扩展性差
    
3. 如何用函数
    1. 先定义
        1. [三种定义方式](%E5%87%BD%E6%95%B0%20df2f4adc6d904a7f96ed291e335bf9dd.md)
    2. 后调用
        1. [三种调用方式](%E5%87%BD%E6%95%B0%20df2f4adc6d904a7f96ed291e335bf9dd.md)
    3.  返回值
        1. [三种返回值的形式](%E5%87%BD%E6%95%B0%20df2f4adc6d904a7f96ed291e335bf9dd.md)
        

### 三种定义方式

```python
定义的语法
# '''
# def 函数名(参数1,参数2,...):
    # """文档描述"""
    # 函数体
    # return 值
# '''

形式一：无参函数
def func():
    # x
    # print(
    print('哈哈哈')
    print('哈哈哈')
    print('哈哈哈')

定义函数发生的事情
1、申请内存空间保存函数体代码
2、将上述内存地址绑定函数名
3、定义函数不会执行函数体代码，但是会检测函数体语法

调用函数发生的事情
1、通过函数名找到函数的内存地址
2、然后加口号就是在触发函数体代码的执行
print(func)
func()

示范1
def bar(): # bar=函数的内存地址
    print('from bar')

def foo():
    # print(bar)
    bar()
    print('from foo')

foo()

示范2
def foo():
    # print(bar)
    bar()
    print('from foo')

def bar():  # bar=函数的内存地址
    print('from bar')

foo()

示范3
def foo():
    # print(bar)
    bar()
    print('from foo')

foo()

def bar():  # bar=函数的内存地址
    print('from bar')

形式二：有参函数
def func(x,y): # x=1  y=2
    print(x,y)
func(1,2)

形式三：空函数,函数体代码为pass
def func(x, y):
    pass

三种定义方式各用在何处
1、无参函数的应用场景
def interactive():
    name=input('username>>: ')
    age=input('age>>: ')
    gender=input('gender>>: ')
    msg='名字：{} 年龄：{} 性别'.format(name,age,gender)
    print(msg)

interactive()
interactive()
interactive()
interactive()

2、有参函数的应用场景
def add(x,y): # 参数-》原材料
    # x=20
    # y=30
    res=x + y
    # print(res)
    return res # 返回值-》产品

# add(10,2)
res=add(20,30)
print(res)

3、空函数的应用场景
def auth_user():
    """user authentication function"""
    pass

def download_file():
    """download file function"""
    pass

def upload_file():
    """upload file function"""
    pass

def ls():
    """list contents function"""
    pass

def cd():
    """change directory"""
    pass
```

### 三种调用方式

```python
二、调用函数
1、语句的形式:只加括号调用函数
interactive()
add(1,2)

2、表达式形式：
def add(x,y): # 参数-》原材料
    res=x + y
    return res # 返回值-》产品
赋值表达式
res=add(1,2)
print(res)
数学表达式
res=add(1,2)*10
print(res)

3、函数调用可以当做参数
res=add(add(1,2),10)
print(res)
```

### 三种返回值的形式

```python
三、函数返回值
return是函数结束的标志，即函数体代码一旦运行到return会立刻
终止函数的运行，并且会将return后的值当做本次运行的结果返回：
1、返回None：函数体内没有return
            return
            return None

2、返回一个值：return 值
def func():
    return 10

res=func()
print(res)

3、返回多个值：用逗号分隔开多个值，会被return返回成元组
def func():
    return 10, 'aa', [1, 2]

res = func()
print(res, type(res))
```

### 函数参数的使用

```python
一 形参与实参介绍
形参：在定义函数阶段定义的参数称之为形式参数，简称形参,相当于变量名
def func(x, y):  # x=1，y=2
    print(x, y)

实参：在调用函数阶段传入的值称之为实际参数，简称实参，相当于变量值
func(1,2)

形参与实参的关系：
1、在调用阶段，实参（变量值）会绑定给形参（变量名）
2、这种绑定关系只能在函数体内使用
3、实参与形参的绑定关系在函数调用时生效，函数调用结束后解除绑定关系

实参是传入的值，但值可以是以下形式
形式一：
func(1,2)

形式二：
a=1
b=2
func(a,b)

形式三：
func(int('1'),2)
func(func1(1,2,),func2(2,3),333)

二 形参与实参的具体使用
2.1 位置参数：按照从左到右的顺序依次定义的参数称之为位置参数
位置形参:在函数定义阶段，按照从左到右的顺序直接定义的"变量名"
       特点：必须被传值，多一个不行少一个也不行
def func(x,y):
    print(x,y)
func(1,2,3)
func(1,)

位置实参:在函数调用阶段， 按照从左到有的顺序依次传入的值
       特点：按照顺序与形参一一对应

func(1,2)
func(2,1)

2.2 关键字参数
关键字实参：在函数调用阶段，按照key=value的形式传入的值
      特点：指名道姓给某个形参传值，可以完全不参照顺序
def func(x,y):
    print(x,y)

func(y=2,x=1)
func(1,2)

混合使用，强调
1、位置实参必须放在关键字实参前
func(1,y=2)
func(y=2,1)

2、不能能为同一个形参重复传值
func(1,y=2,x=3)
func(1,2,x=3,y=4)

2.3 默认参数
默认形参：在定义函数阶段，就已经被赋值的形参，称之为默认参数
      特点：在定义阶段就已经被赋值，意味着在调用阶段可以不用为其赋值
def func(x,y=3):
    print(x,y)

# func(x=1)
func(x=1,y=44444)

def register(name,age,gender='男'):
    print(name,age,gender)

register('三炮',18)
register('二炮',19)
register('大炮',19)
register('没炮',19,'女')

位置形参与默认形参混用，强调：
1、位置形参必须在默认形参的左边
def func(y=2,x):
    pass

2、默认参数的值是在函数定义阶段被赋值的，准确地说被赋予的是值的内存地址
示范1：
m=2
def func(x,y=m): # y=>2的内存地址
    print(x,y
m=3333333333333333333
func(1)

示范2：
m = [111111, ]

def func(x, y=m): # y=>[111111, ]的内存地址
    print(x, y)

m.append(3333333)
func(1)

3、虽然默认值可以被指定为任意数据类型，但是不推荐使用可变类型
函数最理想的状态：函数的调用只跟函数本身有关系，不外界代码的影响
m = [111111, ]

def func(x, y=m):
    print(x, y)

m.append(3333333)
m.append(444444)
m.append(5555)

func(1)
func(2)
func(3)

def func(x,y,z,l=None):
    if l is None:
        l=[]
    l.append(x)
    l.append(y)
    l.append(z)
    print(l)

func(1,2,3)
func(4,5,6)

new_l=[111,222]
func(1,2,3,new_l)

2.4 可变长度的参数（*与**的用法）
可变长度指的是在调用函数时，传入的值（实参）的个数不固定
而实参是用来为形参赋值的，所以对应着，针对溢出的实参必须有对应的形参来接收

2.4.1 可变长度的位置参数
I：*形参名：用来接收溢出的位置实参，溢出的位置实参会被*保存成元组的格式然后赋值紧跟其后的形参名
          *后跟的可以是任意名字，但是约定俗成应该是args

def func(x,y,*z): # z =（3,4,5,6）
    print(x,y,z)

func(1,2,3,4,5,6)

def my_sum(*args):
    res=0
    for item in args:
        res+=item
    return res

res=my_sum(1,2,3,4,)
print(res)

II: *可以用在实参中，实参中带*，先*后的值打散成位置实参
def func(x,y,z):
    print(x,y,z)

# func(*[11,22,33]) # func(11，22，33)
# func(*[11,22]) # func(11，22)

l=[11,22,33]
func(*l)

III: 形参与实参中都带*
def func(x,y,*args): # args=(3,4,5,6)
    print(x,y,args)

func(1,2,[3,4,5,6])
func(1,2,*[3,4,5,6]) # func(1,2,3,4,5,6)
func(*'hello') # func('h','e','l','l','o')

2.4.2 可变长度的关键字参数
I：**形参名：用来接收溢出的关键字实参，**会将溢出的关键字实参保存成字典格式，然后赋值给紧跟其后的形参名
          **后跟的可以是任意名字，但是约定俗成应该是kwargs
def func(x,y,**kwargs):
    print(x,y,kwargs)

func(1,y=2,a=1,b=2,c=3)

II: **可以用在实参中(**后跟的只能是字典)，实参中带**，先**后的值打散成关键字实参
def func(x,y,z):
    print(x,y,z)

func(*{'x':1,'y':2,'z':3}) # func('x','y','z')
func(**{'x':1,'y':2,'z':3}) # func(x=1,y=2,z=3)

错误
func(**{'x':1,'y':2,}) # func(x=1,y=2)
func(**{'x':1,'a':2,'z':3}) # func(x=1,a=2,z=3)

III: 形参与实参中都带**
def func(x,y,**kwargs):
    print(x,y,kwargs)

func(y=222,x=111,a=333,b=444)
func(**{'y':222,'x':111,'a':333,'b':4444})

混用*与**：*args必须在**kwargs之前
def func(x,*args,**kwargs):
    print(args)
    print(kwargs)

func(1,2,3,4,5,6,7,8,x=1,y=2,z=3)

# def index(x,y,z):
    # print('index=>>> ',x,y,z)

# def wrapper(*args,**kwargs): #args=(1,) kwargs={'z':3,'y':2}
    # index(*args,**kwargs)
    index(*(1,),**{'z':3,'y':2})
    index(1,z=3,y=2)

# wrapper(1,z=3,y=2) # 为wrapper传递的参数是给index用的
原格式---》汇总-----》打回原形

1. 命名关键字参数（了解）
 命名关键字参数：在定义函数时，*后定义的参数，如下所示，称之为命名关键字参数
特点：
1、命名关键字实参必须按照key=value的形式为其传值
def func(x,y,*,a,b): # 其中，a和b称之为命名关键字参数
    print(x,y)
    print(a,b)

# func(1,2,b=222,a=111)

示例
def func(x,y,*,a=11111,b):
    print(x,y)
    print(a,b)

func(1,2,b=22222)

2. 组合使用（了解）
形参混用的顺序：位置新参，默认形参,*args,命名关键字形参，**kwargs
def func(x,y=111,*args,z,**kwargs):
    print(x)
    print(y)
    print(args)
    print(z)
    print(kwargs)

实参混用的顺序：
def func(x,y,z,a,b,c):
    print(x)
    print(y)
    print(z)
    print(a)
    print(b)
    print(c)

func(111,y=222,*[333,444],**{'b':555,'c':666})
func(111,y=222,333,444,b=555,c=666)

func(111,*[333,444],a=222,**{'b':555,'c':666})
func(111,333,444,a=222,b=555,c=66)

func(111,*[333,444],**{'b':555,'c':666},a=222,)
# func(111,3333,4444,b=555,c=666,a=222)

func(1)
func(x=1)
func(1,x=1)
func(*'hello')
func(**{})
func(*'hell',**{})
```

## 名称空间与作用域

```python
一：名称空间namespacs：存放名字的地方，是对栈区的划分
有了名称空间之后，就可以在栈区中存放相同的名字，详细的，名称空间
分为三种
1.1 内置名称空间
存放的名字：存放的python解释器内置的名字
# '''
# >>> print
# <built-in function print>
# >>> input
# <built-in function input>
# '''
存活周期：python解释器启动则产生，python解释器关闭则销毁

1.2 全局名称空间
存放的名字：只要不是函数内定义、也不是内置的，剩下的都是全局名称空间的名字
存活周期：python文件执行则产生，python文件运行完毕后销毁

import os

x=10
if 13 > 3:
    y=20
    if 3 == 3:
        z=30

# func=函数的内存地址
def func():
    a=111
    b=222

class Foo:
    pass

1.3 局部名称空间
存放的名字：在调用函数时，运行函数体代码过程中产生的函数内的名字
存活周期：在调用函数时存活，函数调用完毕后则销毁
def func(a,b):
    pass

func(10,1)
func(11,12)
func(13,14)
func(15,16)

1.4 名称空间的加载顺序
内置名称空间>全局名称空间>局部名称空间

1.5 销毁顺序
局部名称空间>全局名空间>内置名称空间

1.6 名字的查找优先级：当前所在的位置向上一层一层查找
内置名称空间
全局名称空间
局部名称空间

如果当前在局部名称空间：
局部名称空间—>全局名称空间->内置名称空间
# input=333

def func():
    # input=444
    print(input)

func()

如果当前在全局名称空间
全局名称空间->内置名称空间
input=333
def func():
    input=444
func()
print(input)

示范1:
def func():
    print(x)
x=111

func()

示范2：名称空间的"嵌套"关系是以函数定义阶段为准，与调用位置无关
x=1
def func():
   print(x)

def foo():
    x=222
    func()

foo()

示范3：函数嵌套定义
input=111
def f1():
    def f2():
        # input=333
        print(input)
    input=222
    f2()

f1()

示范4：
x=111
def func():
    print(x) #
    x=222

func()

二：作用域-》作用范围
全局作用域：内置名称空间、全局名称空间
1、全局存活
2、全局有效:被所有函数共享

x=111

def foo():
    print(x,id(x))

def bar():
    print(x,id(x))

foo()
bar()

print(x,id(x))

局部作用域: 局部名称空间的名字
1、临时存活
2、局部有效:函数内有效

def foo(x):
    def f1():
        def f2():
            print(x)

LEGB
# builtin
# global
def f1():
    # enclosing
    def f2():
        # enclosing
        def f3():
            # local
            pass
```

## global与nonlocal

```python
示范1：
x=111

def func():
    x=222

func()
print(x)

示范2：如果再局部想要修改全局的名字对应的值（不可变类型），需要用global
x=111

def func():
    global x # 声明x这个名字是全局的名字，不要再造新的名字了
    x=222

func()
print(x)

示范3：
l=[111,222]
def func():
    l.append(333)

func()
print(l)

nonlocal(了解): 修改函数外层函数包含的名字对应的值（不可变类型）
x=0
def f1():
    x=11
    def f2():
        nonlocal x
        x=22
    f2()
    print('f1内的x：',x)

f1()

def f1():
    x=[]
    def f2():
        x.append(1111)
    f2()
    print('f1内的x：',x)

f1()
```

## 函数对象

```python
# 精髓：可以把函数当成变量去用
# func=内存地址
def func():
    print('from func')

# 1、可以赋值
# f=func
# print(f,func)
# f()

# 2、可以当做函数当做参数传给另外一个函数
# def foo(x): # x = func的内存地址
#     # print(x)
#     x()
#
# foo(func) # foo(func的内存地址)

# 3、可以当做函数当做另外一个函数的返回值
# def foo(x): # x=func的内存地址
#     return x # return func的内存地址
#
# res=foo(func) # foo（func的内存地址）
# print(res) # res=func的内存地址
#
# res()

# 4、可以当做容器类型的一个元素
# l=[func,]
# # print(l)
# l[0]()

# dic={'k1':func}
# print(dic)
# dic['k1']()

# 函数对象应用示范：
# def login():
#     print('登录功能')
#
#
# def transfer():
#     print('转账功能')
#
#
# def check_banlance():
#     print('查询余额')
#
# def withdraw():
#     print('提现')
#
#
# def register():
#     print('注册')
#
# func_dic={
#     '1':login,
#     '2':transfer,
#     '3':check_banlance,
#     '4':withdraw,
#     '5':register
# }
#
# # func_dic['1']()
#
#
# while True:
#     print("""
#     0 退出
#     1 登录
#     2 转账
#     3 查询余额
#     4 提现
#     5 注册
#     """)
#     choice = input('请输入命令编号：').strip()
#     if not choice.isdigit():
#         print('必须输入编号，傻叉')
#         continue
#
#     if choice == '0':
#         break
#
#
#     if choice in func_dic:
#         func_dic[choice]()
#     else:
#         print('输入的指令不存在')
#
#     # if choice == '1':
#     #     login()
#     # elif choice == '2':
#     #     transfer()
#     # elif choice == '3':
#     #     check_banlance()
#     # elif choice == '4':
#     #     withdraw()
#     # else:
#     #     print('输入的指令不存在')

# 修正
def login():
    print('登录功能')

def transfer():
    print('转账功能')

def check_banlance():
    print('查询余额')

def withdraw():
    print('提现')

def register():
    print('注册')

func_dic = {
    '0': ['退出', None],
    '1': ['登录', login],
    '2': ['转账', transfer],
    '3': ['查询余额', check_banlance],
    '4': ['提现', withdraw],
    '5': ['注册', register]
}
# func_dic['1']()

while True:
    for k in func_dic:
        print(k, func_dic[k][0])

    choice = input('请输入命令编号：').strip()
    if not choice.isdigit():
        print('必须输入编号，傻叉')
        continue

    if choice == '0':
        break

    # choice='1'
    if choice in func_dic:
        func_dic[choice][1]()
    else:
        print('输入的指令不存在')
```

## 函数嵌套

```python
函数嵌套
1、函数的嵌套调用：在调用一个函数的过程中又调用其他函数
def max2(x,y):
    if x > y:
        return x
    else:
        return y

def max4(a,b,c,d):
    # 第一步：比较a，b得到res1
    res1=max2(a,b)
    # 第二步：比较res1，c得到res2
    res2=max2(res1,c)
    # 第三步：比较res2，d得到res3
    res3=max2(res2,d)
    return res3

res=max4(1,2,3,4)
print(res)

2、函数的嵌套定义:在函数内定义其他函数
def f1():
    def f2():
        pass

# 圆形
# 求圆形的求周长：2*pi*radius
def circle(radius,action=0):
    from math import pi

    def perimiter(radius):
        return 2*pi*radius

    # 求圆形的求面积：pi*(radius**2)
    def area(radius):
        return pi*(radius**2)

    if action == 0:
        return 2*pi*radius

    elif action == 1:
        return area(radius)

circle(33,action=0)
```

## 闭包函数

```python
一：大前提：
闭包函数=名称空间与作用域+函数嵌套+函数对象
       核心点：名字的查找关系是以函数定义阶段为准

二：什么是闭包函数
"闭"函数指的该函数是内嵌函数
"包"函数指的该函数包含对外层函数作用域名字的引用（不是对全局作用域）

闭包函数：名称空间与作用域的应用+函数嵌套
def f1():
    x = 33333333333333333333
    def f2():
        print(x)
    f2()

x=11111
def bar():
    x=444444
    f1()

def foo():
    x=2222
    bar()

foo()

闭包函数：函数对象
def f1():
    x = 33333333333333333333
    def f2():
        print('函数f2：',x)
    return f2

f=f1()
# print(f)

# x=4444
# f()
def foo():
    x=5555
    f()

foo()

三：为何要有闭包函数=》闭包函数的应用
两种为函数体传参的方式
方式一：直接把函数体需要的参数定义成形参
def f2(x):
    print(x)

f2(1)
f2(2)
f2(3)

方式二：
def f1(x): # x=3
    x=3
    def f2():
        print(x)
    return f2

x=f1(3)
print(x)

x()

# import requests
传参的方案一：
def get(url):
    response=requests.get(url)
    print(len(response.text))

get('https://www.baidu.com')
get('https://www.cnblogs.com/linhaifeng')
get('https://zhuanlan.zhihu.com/p/109056932')

# 传参的方案二：
def outter(url):
    # url='https://www.baidu.com'
    def get():
        response=requests.get(url)
        print(len(response.text))
    return get

baidu=outter('https://www.baidu.com')
baidu()

cnblogs=outter('https://www.cnblogs.com/linhaifeng')
cnblogs()

zhihu=outter('https://zhuanlan.zhihu.com/p/109056932')
zhihu()
```

## 函数的递归

```python
一：递归的定义
函数的递归调用：是函数嵌套调用的一种特殊形式
具体是指：
       在调用一个函数的过程中又直接或者间接地调用到本身

直接调用本身
def f1():
    print('是我是我还是我')
    f1()
f1()

间接接调用本身
def f1():
    print('===>f1')
    f2()

def f2():
    print('===>f2')
    f1()

f1()

一段代码的循环运行的方案有两种
方式一：while、for循环
while True:
    print(1111)
    print(2222)
    print(3333)

方式二：递归的本质就是循环：
def f1():
    print(1111)
    print(2222)
    print(3333)
    f1()
f1()

二：需要强调的的一点是：
递归调用不应该无限地调用下去，必须在满足某种条件下结束递归调用
n=0
while n < 10:
    print(n)
    n+=1

def f1(n):
    if n == 10:
        return
    print(n)
    n+=1
    f1(n)

f1(0)

三：递归的两个阶段
回溯：一层一层调用下去
递推：满足某种结束条件，结束递归调用，然后一层一层返回

age(5) = age(4) + 10
age(4) = age(3) + 10
age(3) = age(2) + 10
age(2) = age(1) + 10
age(1) = 18

def age(n):
    if n == 1:
        return 18
    return age(n-1) + 10

res=age(5)
print(res)

# 四：递归的应用
l=[1,2,[3,[4,[5,[6,[7,[8,[9,10,11,[12,[13,]]]]]]]]]]

def f1(list1):
    for x in list1:
        if type(x) is list:
            # 如果是列表，应该再循环、再判断,即重新运行本身的代码
            f1(x)
        else:
            print(x)

f1(l)
```