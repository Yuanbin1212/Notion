# 装饰器

Last edited time: May 4, 2023 2:00 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: Python

# 无参装饰器

```python
一：储备知识
1、 *args， **kwargs
def index(x,y):
    print(x,y)

def wrapper(*args,**kwargs):
    index(*args,**kwargs) #
                          # index(y=222,x=111)
wrapper(y=222,x=111)

2、名称空间与作用域：名称空间的的"嵌套"关系是在函数定义阶段，即检测语法的时候确定的

3、函数对象：
   可以把函数当做参数传入
   可以把函数当做返回值返回
def index():
    return 123

def foo(func):
    return func

foo(index)

4、函数的嵌套定义:
def outter(func):
    def wrapper():
        pass
    return wrapper

闭包函数
def outter():
    x=111
    def wrapper():
        x
    return wrapper

f=outter()

传参的方式一：通过参数的形式为函数体传值

def wrapper(x):
    print(1)
    print(2)
    print(3)
    x

wrapper(1)
wrapper(2)
wrapper(3)
传参的方式二：通过闭包的方式为函数体传值
def outter(x):
    # x=1
    def wrapper():
        print(1)
        print(2)
        print(3)
        x
    return wrapper # return outter内的wrapper那个函数的内地址

# f1=outter(1)
# f2=outter(2)
# f3=outter(3)

wrapper=outter(1)

二 装饰器
# """
# 1、什么是装饰器
    # 器指的是工具，可以定义成成函数
    # 装饰指的是为其他事物添加额外的东西点缀
    
    # 合到一起的解释：
        # 装饰器指的定义一个函数，该函数是用来为其他函数添加额外的功能
        
    
# 2、为何要用装饰器
    # 开放封闭原则
        # 开放：指的是对拓展功能是开放的
        # 封闭：指的是对修改源代码是封闭的
        
    # 装饰器就是在不修改被装饰器对象源代码以及调用方式的前提下为被装饰对象添加新功能
# 3、如何用
# """
需求：在不修改index函数的源代码以及调用方式的前提下为其添加统计运行时间的功能
def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))

index(111,222)
# index(y=111,x=222)
# index(111,y=222)

解决方案一：失败
问题：没有修改被装饰对象的调用方式，但是修改了其源代码
import time

def index(x,y):
    start=time.time()
    time.sleep(3)
    print('index %s %s' %(x,y))
    stop = time.time()
    print(stop - start)

index(111,222)

解决方案二：失败
问题：没有修改被装饰对象的调用方式，也没有修改了其源代码，并且加上了新功能
     但是代码冗余
import time

def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))

start=time.time()
index(111,222)
stop=time.time()
print(stop - start)

start=time.time()
index(111,222)
stop=time.time()
print(stop - start)

start=time.time()
index(111,222)
stop=time.time()
print(stop - start)

解决方案三：失败
问题：解决了方案二代码冗余问题，但带来一个新问题即函数的调用方式改变了
import time

def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))

def wrapper():
    start=time.time()
    index(111,222)
    stop=time.time()
    print(stop - start)

wrapper()

方案三的优化一：将index的参数写活了
import time

def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

def wrapper(*args,**kwargs):
    start=time.time()
    index(*args,**kwargs) # index(3333,z=5555,y=44444)
    stop=time.time()
    print(stop - start)

# wrapper(3333,4444,5555)
# wrapper(3333,z=5555,y=44444)

方案三的优化二：在优化一的基础上把被装饰对象写活了，原来只能装饰index
import time

def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

def home(name):
    time.sleep(2)
    print('welcome %s to home page' %name)

def outter(func):
    # func = index的内存地址
    def wrapper(*args,**kwargs):
        start=time.time()
        func(*args,**kwargs) # index的内存地址()
        stop=time.time()
        print(stop - start)
    return wrapper

index=outter(index) # index=wrapper的内存地址
home=outter(home) # home=wrapper的内存地址

home('egon')
# home(name='egon')

方案三的优化三：将wrapper做的跟被装饰对象一模一样，以假乱真
import time

def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

def home(name):
    time.sleep(2)
    print('welcome %s to home page' %name)

def outter(func):
    def wrapper(*args,**kwargs):
        start=time.time()
        res=func(*args,**kwargs)
        stop=time.time()
        print(stop - start)
        return res
    return wrapper

# 偷梁换柱：home这个名字指向的wrapper函数的内存地址
home=outter(home)

res=home('egon') # res=wrapper('egon')
print('返回值--》',res)

大方向：如何在方案三的基础上不改变函数的调用方式

语法糖：让你开心的语法
# import time

装饰器
def timmer(func):
    def wrapper(*args,**kwargs):
        start=time.time()
        res=func(*args,**kwargs)
        stop=time.time()
        print(stop - start)
        return res
    return wrapper

# 在被装饰对象正上方的单独一行写@装饰器名字
# @timmer # index=timmer(index)
def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

# @timmer # home=timmer(ome)
def home(name):
    time.sleep(2)
    print('welcome %s to home page' %name)

index(x=1,y=2,z=3)
home('egon')

思考题（选做），叠加多个装饰器，加载顺序与运行顺序
@deco1 # index=deco1(deco2.wrapper的内存地址)
@deco2 # deco2.wrapper的内存地址=deco2(deco3.wrapper的内存地址)
@deco3 # deco3.wrapper的内存地址=deco3(index)
def index():
    pass

总结无参装饰器模板
def outter(func):
    def wrapper(*args,**kwargs):
        # 1、调用原函数
        # 2、为其增加新功能
        res=func(*args,**kwargs)
        return res
    return wrapper

def auth(func):
    def wrapper(*args,**kwargs):
        # 1、调用原函数
        # 2、为其增加新功能
        name=input('your name>>: ').strip()
        pwd=input('your password>>: ').strip()
        if name == 'egon' and pwd == '123':
            res=func(*args,**kwargs)
            return res
        else:
            print('账号密码错误')
    return wrapper

@auth
def index():
    print('from index')

index()

#偷梁换柱，即将原函数名指向的内存地址偷梁换柱成wrapper函数
#        所以应该将wrapper做的跟原函数一样才行
from functools import wraps

def outter(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """这个是主页功能"""
        res = func(*args, **kwargs) # res=index(1,2)
        return res

    # 手动将原函数的属性赋值给wrapper函数
    # 1、函数wrapper.__name__ = 原函数.__name__
    # 2、函数wrapper.__doc__ = 原函数.__doc__
    # wrapper.__name__ = func.__name__
    # wrapper.__doc__ = func.__doc__

    return wrapper

@outter # index=outter(index)
def index(x,y):
    """这个是主页功能"""
    print(x,y)

print(index.__name__)
print(index.__doc__) #help(index)
```

# 有参装饰器

```python
一：知识储备
由于语法糖@的限制，outter函数只能有一个参数，并且该才是只用来接收
                                      被装饰对象的内存地址
def outter(func):
    # func = 函数的内存地址
    def wrapper(*args,**kwargs):
        res=func(*args,**kwargs)
        return res
    return wrapper

# @outter # index=outter(index) # index=>wrapper
@outter # outter(index)
def index(x,y):
    print(x,y)

偷梁换柱之后
index的参数什么样子，wrapper的参数就应该什么样子
index的返回值什么样子，wrapper的返回值就应该什么样子
index的属性什么样子，wrapper的属性就应该什么样子==》from functools import wraps

山炮玩法：
def auth(func,db_type):
    def wrapper(*args, **kwargs):
        name=input('your name>>>: ').strip()
        pwd=input('your password>>>: ').strip()

        if db_type == 'file':
            print('基于文件的验证')
            if name == 'egon' and pwd == '123':
                res = func(*args, **kwargs)
                return res
            else:
                print('user or password error')
        elif db_type == 'mysql':
            print('基于mysql的验证')
        elif db_type == 'ldap':
            print('基于ldap的验证')
        else:
            print('不支持该db_type')

    return wrapper

# @auth  # 账号密码的来源是文件
def index(x,y):
    print('index->>%s:%s' %(x,y))

# @auth # 账号密码的来源是数据库
def home(name):
    print('home->>%s' %name)

# @auth # 账号密码的来源是ldap
def transfer():
    print('transfer')

index=auth(index,'file')
home=auth(home,'mysql')
transfer=auth(transfer,'ldap')

# index(1,2)
# home('egon')
# transfer()

山炮二
def auth(db_type):
    def deco(func):
        def wrapper(*args, **kwargs):
            name=input('your name>>>: ').strip()
            pwd=input('your password>>>: ').strip()

            if db_type == 'file':
                print('基于文件的验证')
                if name == 'egon' and pwd == '123':
                    res = func(*args, **kwargs)
                    return res
                else:
                    print('user or password error')
            elif db_type == 'mysql':
                print('基于mysql的验证')
            elif db_type == 'ldap':
                print('基于ldap的验证')
            else:
                print('不支持该db_type')

        return wrapper
    return deco

deco=auth(db_type='file')
@deco # 账号密码的来源是文件
def index(x,y):
    print('index->>%s:%s' %(x,y))

deco=auth(db_type='mysql')
@deco # 账号密码的来源是数据库
def home(name):
    print('home->>%s' %name)

deco=auth(db_type='ldap')
@deco # 账号密码的来源是ldap
def transfer():
    print('transfer')

index(1,2)
home('egon')
transfer()

# 语法糖
def auth(db_type):
    def deco(func):
        def wrapper(*args, **kwargs):
            name = input('your name>>>: ').strip()
            pwd = input('your password>>>: ').strip()

            if db_type == 'file':
                print('基于文件的验证')
                if name == 'egon' and pwd == '123':
                    res = func(*args, **kwargs)  # index(1,2)
                    return res
                else:
                    print('user or password error')
            elif db_type == 'mysql':
                print('基于mysql的验证')
            elif db_type == 'ldap':
                print('基于ldap的验证')
            else:
                print('不支持该db_type')
        return wrapper
    return deco

@auth(db_type='file')  # @deco # index=deco(index) # index=wrapper
def index(x, y):
    print('index->>%s:%s' % (x, y))

@auth(db_type='mysql')  # @deco # home=deco(home) # home=wrapper
def home(name):
    print('home->>%s' % name)

@auth(db_type='ldap')  # 账号密码的来源是ldap
def transfer():
    print('transfer')

# index(1, 2)
# home('egon')
# transfer()

**# 有参装饰器模板**
def 有参装饰器(x,y,z):
    def outter(func):
        def wrapper(*args, **kwargs):
            res = func(*args, **kwargs)
            return res
        return wrapper
    return outter

@有参装饰器(1,y=2,z=3)
def 被装饰对象():
    pass
```

## 叠加多个装饰器的加载、分析

```python
# 一、叠加多个装饰器的加载、运行分析（了解***）

def deco1(func1): # func1 = wrapper2的内存地址
    def wrapper1(*args,**kwargs):
        print('正在运行===>deco1.wrapper1')
        res1=func1(*args,**kwargs)
        return res1
    return wrapper1

def deco2(func2): # func2 = wrapper3的内存地址
    def wrapper2(*args,**kwargs):
        print('正在运行===>deco2.wrapper2')
        res2=func2(*args,**kwargs)
        return res2
    return wrapper2

def deco3(x):
    def outter3(func3): # func3=被装饰对象index函数的内存地址
        def wrapper3(*args,**kwargs):
            print('正在运行===>deco3.outter3.wrapper3')
            res3=func3(*args,**kwargs)
            return res3
        return wrapper3
    return outter3

# 加载顺序自下而上(了解)
@deco1      # index=deco1(wrapper2的内存地址)        ===> index=wrapper1的内存地址
@deco2      # index=deco2(wrapper3的内存地址)        ===> index=wrapper2的内存地址
@deco3(111) # ===>@outter3===> index=outter3(index) ===> index=wrapper3的内存地址
def index(x,y):
    print('from index %s:%s' %(x,y))

# 执行顺序自上而下的，即wraper1-》wrapper2-》wrapper3
index(1,2) # wrapper1(1,2)
```

![叠加多个装饰器.png](%E8%A3%85%E9%A5%B0%E5%99%A8%2097a811913b9045efbb40f30521f501f4/%E5%8F%A0%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8.png)

## lru_cache装饰器

functools.**lru_cache(maxsize=128, typed=False)**

1. maxsize默认是128，缓存函数输入输出pair的数量
2. typed如果为True，不同类型的入参将被视为不同的输入进行缓存
- functools.lru_cache是一个函数缓存装饰器
- functools.lru_cache装饰函数后，会将函数的输入和输出进行缓存，如果再下次调用此函数时，出现了相同的输入，那么相同的输出就可直接从缓存中提取，函数体本身无需再次执行，用一点内存，加快了速度