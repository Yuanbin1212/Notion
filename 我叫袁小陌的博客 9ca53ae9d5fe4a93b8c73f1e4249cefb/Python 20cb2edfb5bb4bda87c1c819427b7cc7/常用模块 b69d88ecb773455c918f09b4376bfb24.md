# 常用模块

Last edited time: May 4, 2023 2:01 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: Python

## 时间模块

```python
时间模块优先掌握的操作
一：time
import time

时间分为三种格式：
1、时间戳：从1970年到现在经过的秒数
   作用：用于时间间隔的计算

print(time.time())

2、按照某种格式显示的时间：2020-03-30 11:11:11
   作用：用于展示时间

print(time.strftime('%Y-%m-%d %H:%M:%S %p'))
print(time.strftime('%Y-%m-%d %X'))

3、结构化的时间
   作用：用于单独获取时间的某一部分

res=time.localtime()
print(res)
print(res.tm_year)
print(res.tm_yday)

二：datetime
# import datetime

print(datetime.datetime.now())
print(datetime.datetime.now() + datetime.timedelta(days=3))
print(datetime.datetime.now() + datetime.timedelta(weeks=1))

时间模块需要掌握的操作
1、时间格式的转换
struct_time->时间戳
# import time
s_time=time.localtime()
print(time.mktime(s_time))

时间戳->struct_time
tp_time=time.time()
print(time.localtime(tp_time))

补充：世界标准时间与本地时间
print(time.localtime())
print(time.gmtime()) # 世界标准时间，了解
print(time.localtime(333333333))
print(time.gmtime(333333333))

struct_time->格式化的字符串形式的时间
s_time=time.localtime()
print(time.strftime('%Y-%m-%d %H:%M:%S',s_time))

print(time.strptime('1988-03-03 11:11:11','%Y-%m-%d %H:%M:%S'))

!!!真正需要掌握的只有一条：format string<------>timestamp
'1988-03-03 11:11:11'+7

format string--->struct_time--->timestamp
struct_time=time.strptime('1988-03-03 11:11:11','%Y-%m-%d %H:%M:%S')
timestamp=time.mktime(struct_time)+7*86400
print(timestamp)

format string<---struct_time<---timestamp
res=time.strftime('%Y-%m-%d %X',time.localtime(timestamp))
print(res)

time.sleep(3)

了解知识
import time
print(time.asctime())

# import datetime
print(datetime.datetime.now())
print(datetime.datetime.utcnow())

# print(datetime.datetime.fromtimestamp(333333))
```

## random模块

```python
import random

print(random.random()) #(0,1)----float    大于0且小于1之间的小数
print(random.randint(1, 3))  # [1,3]    大于等于1且小于等于3之间的整数

print(random.randrange(1, 3))  # [1,3)    大于等于1且小于3之间的整数

print(random.choice([111, 'aaa', [4, 5]]))  # 1或者23或者[4,5]

print(random.sample([111, 'aaa', 'ccc','ddd'],2))  # 列表元素任意2个组合

print(random.uniform(1, 3))  # 大于1小于3的小数，如1.927109612082716

item = [1, 3, 5, 7, 9]
random.shuffle(item)  # 打乱item的顺序,相当于"洗牌"
print(item)

应用：随机验证码

import random

res=''
for i in range(6):
    从26大写字母中随机取出一个=chr(random.randint(65,90))
    从10个数字中随机取出一个=str(random.randint(0,9))

    随机字符=random.choice([从26大写字母中随机取出一个,从10个数字中随机取出一个])
    res+=随机字符

import random

def make_code(size=4):
    res=''
    for i in range(size):
        s1=chr(random.randint(65,90))
        s2=str(random.randint(0,9))
        res+=random.choice([s1,s2])
    return res

print(make_code(6))
```

## os模块

```python

import os
获取某一个文件夹下所有的子文件以及子文件夹的名字
res=os.listdir('.')
print(res)

size=os.path.getsize(r'/Users/linhaifeng/PycharmProjects/s14/day22/01 时间模块.py')
print(size)

os.remove()  删除一个文件
os.rename("oldname","newname")  重命名文件/目录

应用程序----》"ls /"
os.system("ls /")

规定：key与value必须都为字符串

os.environ['aaaaaaaaaa']='111'
print(os.environ)

print(os.path.dirname(r'/a/b/c/d.txt'))
print(os.path.basename(r'/a/b/c/d.txt'))

print(os.path.isfile(r'笔记.txt'))
print(os.path.isfile(r'aaa'))
print(os.path.isdir(r'aaa'))

print(os.path.join('a','/','b','c','d'))

#推荐用这种
BASE_DIR=os.path.dirname(os.path.dirname(__file__))
print(BASE_DIR)

# BASE_DIR=os.path.normpath(os.path.join(
#    __file__,
#    '..',
#    '..'
# ))
print(BASE_DIR)

在python3.5之后，推出了一个新的模块pathlib
# from pathlib import Path

res = Path(__file__).parent.parent
print(res)

res=Path('/a/b/c') / 'd/e.txt'
print(res)
print(res.resolve())
```

## 序列化与反序列化模块

```python
1、什么是序列化&反序列化
  内存中的数据类型---->序列化---->特定的格式（json格式或者pickle格式）
  内存中的数据类型<----反序列化<----特定的格式（json格式或者pickle格式）

  土办法：
  {'aaa':111}--->序列化str({'aaa':111})----->"{'aaa':111}"
  {'aaa':111}<---反序列化eval("{'aaa':111}")<-----"{'aaa':111}"

2、为何要序列化
  序列化得到结果=>特定的格式的内容有两种用途
  1、可用于存储=》用于存档
  2、传输给其他平台使用=》跨平台数据交互
       python                 java
        列表     特定的格式      数组

  强调：
      针对用途1的特定一格式：可是一种专用的格式=》pickle只有python可以识别
      针对用途2的特定一格式：应该是一种通用、能够被所有语言识别的格式=》json

3、如何序列化与反序列化
示范1
import json
# 序列化
json_res=json.dumps([1,'aaa',True,False])
print(json_res,type(json_res)) # "[1, "aaa", true, false]"

# 反序列化
l=json.loads(json_res)
print(l,type(l))

示范2：
import json
序列化的结果写入文件的复杂方法
json_res=json.dumps([1,'aaa',True,False])
# print(json_res,type(json_res)) # "[1, "aaa", true, false]"
with open('test.json',mode='wt',encoding='utf-8') as f:
    f.write(json_res)

将序列化的结果写入文件的简单方法
with open('test.json',mode='wt',encoding='utf-8') as f:
    json.dump([1,'aaa',True,False],f)

从文件读取json格式的字符串进行反序列化操作的复杂方法
with open('test.json',mode='rt',encoding='utf-8') as f:
    json_res=f.read()
    l=json.loads(json_res)
    print(l,type(l))

从文件读取json格式的字符串进行反序列化操作的简单方法
with open('test.json',mode='rt',encoding='utf-8') as f:
    l=json.load(f)
    print(l,type(l))

json验证: json格式兼容的是所有语言通用的数据类型，不能识别某一语言的所独有的类型
json.dumps({1,2,3,4,5})

json强调：一定要搞清楚json格式，不要与python混淆
l=json.loads('[1, "aaa", true, false]')
l=json.loads("[1,1.3,true,'aaa', true, false]")
print(l[0])

了解
l = json.loads(b'[1, "aaa", true, false]')
print(l, type(l))

with open('test.json',mode='rb') as f:
    l=json.load(f)

res=json.dumps({'name':'哈哈哈'})
print(res,type(res))

res=json.loads('{"name": "\u54c8\u54c8\u54c8"}')
print(res,type(res))

4、猴子补丁
在入口处打猴子补丁
import json
import ujson

def monkey_patch_json():
    json.__name__ = 'ujson'
    json.dumps = ujson.dumps
    json.loads = ujson.loads

monkey_patch_json() # 在入口文件出运行

import ujson as json # 不行

后续代码中的应用
json.dumps()
json.dumps()
json.dumps()
json.dumps()
json.dumps()
json.dumps()
json.dumps()
json.dumps()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()
json.loads()

5.pickle模块
import pickle
res=pickle.dumps({1,2,3,4,5})
print(res,type(res))

s=pickle.loads(res)
print(s,type(s))
```

## configparser模块

```python
import configparser

config=configparser.ConfigParser()
config.read('test.ini')

1、获取sections
print(config.sections())

2、获取某一section下的所有options
print(config.options('section1'))

3、获取items
print(config.items('section1'))

4、
res=config.get('section1','user')
print(res,type(res))

res=config.getint('section1','age')
print(res,type(res))

res=config.getboolean('section1','is_admin')
print(res,type(res))

res=config.getfloat('section1','salary')
print(res,type(res))
```

## hashlib模块

```python
# 1、什么是哈希hash
#    hash一类算法，该算法接受传入的内容，经过运算得到一串hash值
#    hash值的特点：
#I 只要传入的内容一样，得到的hash值必然一样
#II 不能由hash值返解成内容
#III 不管传入的内容有多大，只要使用的hash算法不变，得到的hash值长度是一定

# 2、hash的用途
# 用途1：特点II用于密码密文传输与验证
# 用途2：特点I、III用于文件完整性校验

# 3、如何用
import hashlib

m=hashlib.md5()
m.update('hello'.encode('utf-8'))
m.update('world'.encode('utf-8'))
res=m.hexdigest() # 'helloworld'
print(res)

m1=hashlib.md5('he'.encode('utf-8'))
m1.update('llo'.encode('utf-8'))
m1.update('w'.encode('utf-8'))
m1.update('orld'.encode('utf-8'))
res=m1.hexdigest()# 'helloworld'
print(res)

# 模拟撞库
cryptograph='aee949757a2e698417463d47acac93df'
import hashlib

# 制作密码字段
passwds=[
    'alex3714',
    'alex1313',
    'alex94139413',
    'alex123456',
    '123456alex',
    'a123lex',
]

dic={}
for p in passwds:
    res=hashlib.md5(p.encode('utf-8'))
    dic[p]=res.hexdigest()

# 模拟撞库得到密码
for k,v in dic.items():
    if v == cryptograph:
        print('撞库成功，明文密码是：%s' %k)
        break

# 提升撞库的成本=>密码加盐
import hashlib

m=hashlib.md5()

m.update('天王'.encode('utf-8'))
m.update('alex3714'.encode('utf-8'))
m.update('盖地虎'.encode('utf-8'))
print(m.hexdigest())
```

## subprocess模块

```python
import subprocess

obj=subprocess.Popen('echo 123 ; ls / ; ls /root',shell=True,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.PIPE,
                 )

# print(obj)
# res=obj.stdout.read()
# print(res.decode('utf-8'))

err_res=obj.stderr.read()
print(err_res.decode('utf-8'))
```

## logging模块

```python
import logging

logging.basicConfig(
    # 1、日志输出位置：1、终端 2、文件
    filename='access.log', # 不指定，默认打印到终端

    # 2、日志格式
    format='%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s',

    # 3、时间格式
    datefmt='%Y-%m-%d %H:%M:%S %p',

    # 4、日志级别
    # critical => 50
    # error => 40
    # warning => 30
    # info => 20
    # debug => 10
    level=10,
)

logging.debug('调试debug') # 10
logging.info('消息info')   # 20
logging.warning('警告warn')# 30
logging.error('egon提现失败') # 40
logging.critical('严重critical') # 50
```

## re模块

```python
print(re.findall('\w','aAbc123_*()-='))
print(re.findall('\W','aAbc123_*()-= '))
print(re.findall('\s','aA\rbc\t\n12\f3_*()-= '))
print(re.findall('\S','aA\rbc\t\n12\f3_*()-= '))
print(re.findall('\d','aA\rbc\t\n12\f3_*()-= '))
print(re.findall('\D','aA\rbc\t\n12\f3_*()-= '))
print(re.findall('\D','aA\rbc\t\n12\f3_*()-= '))
print(re.findall('\Aalex',' alexis alex sb'))
                         alex
print(re.findall('sb\Z',' alexis alexsb sb'))
                                      sb\Z
print(re.findall('sb\Z',"""alex
alexis
alex
sb
"""))

print(re.findall('^alex','alexis alex sb'))
print(re.findall('sb$','alexis alex sb'))
print(re.findall('sb$',"""alex
alexis
alex
sb
"""))

print(re.findall('^alex$','alexis alex sb'))
print(re.findall('^alex$','al       ex'))
print(re.findall('^alex$','alex'))

重复匹配：| . | * | ? | .* | .*? | + | {n,m} |
1、.:匹配除了\n之外任意一个字符，指定re.DOTALL之后才能匹配换行符
print(re.findall('a.b','a1b a2b a b abbbb a\nb a\tb a*b'))
                                                  a.b
['a1b','a2b','a b','abb','a\tb','a*b']
print(re.findall('a.b','a1b a2b a b abbbb a\nb a\tb a*b',re.DOTALL))

2、*：左侧字符重复0次或无穷次，性格贪婪
print(re.findall('ab*','a ab abb abbbbbbbb bbbbbbbb'))
                                               ab*
['a','ab','abb','abbbbbbbb']

3、+：左侧字符重复1次或无穷次，性格贪婪
print(re.findall('ab+','a ab abb abbbbbbbb bbbbbbbb'))
                        ab+

4、？：左侧字符重复0次或1次，性格贪婪
print(re.findall('ab?','a ab abb abbbbbbbb bbbbbbbb'))
                                               ab?
['a','ab','ab','ab']

5、{n,m}：左侧字符重复n次到m次，性格贪婪
{0,} => *
{1,} => +
{0,1} => ?
{n}单独一个n代表只出现n次，多一次不行少一次也不行

print(re.findall('ab{2,5}','a ab abb abbb abbbb abbbbbbbb bbbbbbbb'))
ab{2,5}
['abb','abbb','abbbb','abbbbb]

print(re.findall('\d+\.?\d*',"asdfasdf123as1111111.123dfa12adsf1asdf3"))
\d+\.?\d*                                      \d+\.?\d+

[]匹配指定字符一个
print(re.findall('a\db','a1111111b a3b a4b a9b aXb a b a\nb',re.DOTALL))
print(re.findall('a[501234]b','a1111111b a3b a4b a9b aXb a b a\nb',re.DOTALL))
print(re.findall('a[0-5]b','a1111111b a3b a1b a0b a4b a9b aXb a b a\nb',re.DOTALL))
print(re.findall('a[0-9a-zA-Z]b','a1111111b axb a3b a1b a0b a4b a9b aXb a b a\nb',re.DOTALL))
print(re.findall('a[^0-9a-zA-Z]b','a1111111b axb a3b a1b a0b a4b a9b aXb a b a\nb',re.DOTALL))
print(re.findall('a-b','a-b aXb a b a\nb',re.DOTALL))
print(re.findall('a[-0-9\n]b','a-b a0b a1b a8b aXb a b a\nb',re.DOTALL))

长度大于2的不含公共元素的子串重复
(.{3,}).*\1
1. **(pattern)** 匹配pattern并获取这一匹配
2. **.** 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式
3. **{n,}** n是一个非负整数。至少匹配n次 **{n}** 匹配确定的n次
4. ****匹配前面的子表达式零次或多次
5. **\1 \num** 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。
6. .*在一起就表示任意字符出现零次或多次
```

## collections模块

- Counter：字典的子类，提供了可哈希对象的计数功能
    1. elements()：返回一个迭代器，每个元素重复计算的个数，如果一个元素的计数小于1,就会被忽略。
    2. most_common([n])：返回一个列表，提供n个访问频率最高的元素和计数
    3. subtract([iterable-or-mapping])：从迭代对象中减去元素，输入输出可以是0或者负数
    4. update([iterable-or-mapping])：从迭代对象计数元素或者从另一个 映射对象 (或计数器) 添加。
- defaultdict：字典的子类，提供了一个工厂函数，为字典查询提供了默认值
- OrderedDict：字典的子类，保留了他们被添加的顺序,如果在已经存在的key上添加新的值，将会保留原来的key的位置，然后覆盖value值
- namedtuple：创建命名元组子类的工厂函数
    - namedtuple(typename, field_names)
- deque：类似列表容器，实现了在两端快速添加(append)和弹出(pop)
    - append(x)：添加x到右端
    - appendleft(x)：添加x到左端
    - clear()：清楚所有元素，长度变为0
    - copy()：创建一份浅拷贝
    - count(x)：计算队列中个数等于x的元素
    - extend(iterable)：在队列右侧添加iterable中的元素
    - extendleft(iterable)：在队列左侧添加iterable中的元素，注：在左侧添加时，iterable参数的顺序将会反过来添加
    - index(x[,start[,stop]])：返回第 x 个元素（从 start 开始计算，在 stop 之前）。返回第一个匹配，如果没找到的话，升起 ValueError 。
    - insert(i,x)：在位置 i 插入 x 。注：如果插入会导致一个限长deque超出长度 maxlen 的话，就升起一个 IndexError 。
    - pop()：移除最右侧的元素
    - popleft()：移除最左侧的元素
    - remove(value)：移去找到的第一个 value。没有抛出ValueError
    - reverse()：将deque逆序排列。返回 None 。
    - maxlen：队列的最大长度，没有限定则为None。
- ChainMap：类似字典的容器类，将多个映射集合到一个视图里面

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled.png)

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled%201.png)

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled%202.png)

## map模块

**map(function, iterator1,iterator2 ...iteratorN)**

- **map（）函数的输出为<map object at 0x0000002C59601748>的map()对象**
- **我们使用for循环或使用list()方法对输出进行迭代，以获取最终结果**
1. 将map()与Python**内置函数**一起使用
2. 使用map()和**字符串**作为迭代器
3. 将map()与**数字列表**一起使用
    - 将列表中的数据转换为特定类型的数据
4. 在**元组**中使用map()
5. 在**字典**中使用map()
6. 与**集合**set一起使用map()
7. 将map()与**Lambda函数**一起使用
8. 在map()函数内部使用**多个迭代器**
9. 当func函数时None时，同zip()函数
10. 当使用多个**iterator时，只匹配到个数最少的那个**

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled%203.png)

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled%204.png)

![Untitled](%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%20b69d88ecb773455c918f09b4376bfb24/Untitled%205.png)