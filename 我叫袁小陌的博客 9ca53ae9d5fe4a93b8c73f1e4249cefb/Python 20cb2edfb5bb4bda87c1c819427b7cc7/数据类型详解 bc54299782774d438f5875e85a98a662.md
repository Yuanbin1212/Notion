# 数据类型详解

Last edited time: May 4, 2023 2:00 PM
Level: 二级标题
Owner: 我叫袁小陌
Tags: Python

1. 数字类型

```python
一：int类型
1、作用：
2、定义：
age = 10 # age=int(10)

名字(参数)
print('hello','world')

x=int(10)
name=input('xxx')
res=print('xxx') # 没有产品
print(res)

2、类型转换
2.1 纯数字的字符串转成int
res=int('100111')
print(res,type(res))

2.2（了解）
2.2.1 十进制转成其他进制
10进制 -> 二进制
11 - > 1011
1011-> 8+2+1
print(bin(11)) # 0b1011

10进制 -> 八进制
print(oct(11)) # 0o13

10进制 -> 十六进制
print(hex(11)) # 0xb
print(hex(123)) # 0xb

2.2.2 其他制转成其十进制
二进制->10进制
print(int('0b1011',2)) # 11

二进制->8进制
print(int('0o13',8)) # 11

二进制->16进制
print(int('0xb',16)) # 11

3、使用

二：float类型
1、作用
2、定义
salary=3.1 # salary=float(3.1)

3、类型转换
res=float("3.1")
print(res,type(res))

4、使用
int与float没有需要掌握的内置方法
他们的使用就是数学运算+比较运算
```

1. 字符串类型

```python
1、作用
2、定义
msg='hello' # msg=str('msg')
print(type(msg))

3、类型转换
str可以把任意其他类型都转成字符串
res=str({'a.txt':1})
print(res,type(res))

4、使用：内置方法
4.1 优先掌握
4.1.1、按索引取值(正向取+反向取) ：只能取
msg='hello world'
正向取
print(msg[0])
print(msg[5])
反向取
print(msg[-1])

只能取
msg[0]='H'

4.1.2、切片:索引的拓展应用，从一个大字符串中拷贝出一个子字符串
msg='hello world'
顾头不顾尾
res=msg[0:5] #x
print(res)
print(msg)

步长
res=msg[0:5:2] # 0 2 4
print(res) # hlo

反向步长(了解)
res=msg[5:0:-1]
print(res) #" olle"

msg='hello world'
res=msg[:] # res=msg[0:11]
print(res)

res=msg[::-1] # 把字符串倒过来
print(res)

4.1.3、长度len
msg='hello world'
print(len(msg))

4.1.4、成员运算in和not in
判断一个子字符串是否存在于一个大字符串中
print("alex" in "alex is sb")
print("alex" not in "alex is sb")
print(not "alex" in "alex is sb") # 不推荐使用

4.1.5、移除字符串左右两侧的符号strip
默认去掉的空格
msg='      egon      '
res=msg.strip()
print(msg) # 不会改变原值
print(res) # 是产生了新值

默认去掉的空格
msg='****egon****'
print(msg.strip('*'))

了解：strip只取两边，不去中间
msg='****e*****gon****'
print(msg.strip('*'))

msg='**/*=-**egon**-=()**'
print(msg.strip('*/-=()'))

应用
inp_user=input('your name>>: ').strip() # inp_user=" egon"
inp_pwd=input('your password>>: ').strip()
if inp_user == 'egon' and inp_pwd == '123':
    print('登录成功')
else:
    print('账号密码错误')

4.1.6、切分split：把一个字符串按照某种分隔符进行切分，得到一个列表
# 默认分隔符是空格
info='egon 18 male'
res=info.split()
print(res)

# 指定分隔符
info='egon:18:male'
res=info.split(':')
print(res)

指定分隔次数(了解)
info='egon:18:male'
res=info.split(':',1)
print(res)

4.1.7、循环
info='egon:18:male'
for x in info:
    print(x)

4.2 需要掌握
4.2.1、strip,lstrip,rstrip
msg='***egon****'
print(msg.strip('*'))
print(msg.lstrip('*'))
print(msg.rstrip('*'))

4.2.2、lower,upper
msg='AbbbCCCC'
print(msg.lower())
print(msg.upper())

4.2.3、startswith,endswith
print("alex is sb".startswith("alex"))
print("alex is sb".endswith('sb'))

4.2.4、format

4.2.5、split,rsplit:将字符串切成列表
info="egon:18:male"
print(info.split(':',1)) # ["egon","18:male"]
print(info.rsplit(':',1)) # ["egon:18","male"]

4.2.6、join: 把列表拼接成字符串
l=['egon', '18', 'male']
res=l[0]+":"+l[1]+":"+l[2]
res=":".join(l) # 按照某个分隔符号，把元素全为字符串的列表拼接成一个大字符串
print(res)

l=[1,"2",'aaa.txt']
":".join(l)

4.2.7、replace
msg="you can you up no can no bb"
print(msg.replace("you","YOU",))
print(msg.replace("you","YOU",1))

4.2.8、isdigit
判断字符串是否由纯数字组成
print('123'.isdigit())
print('12.3'.isdigit())

age=input('请输入你的年龄：').strip()
if age.isdigit():
    age=int(age) # int("abbab")
    if age > 18:
        print('猜大了')
    elif age < 18:
        print('猜小了')
    else:
        print('才最了')
else:
    print('必须输入数字，傻子')

4.3了解
4.3.1、find,rfind,index,rindex,count
msg='hello egon hahaha'
找到返回起始索引
print(msg.find('e')) # 返回要查找的字符串在大字符串中的起始索引
print(msg.find('egon'))
print(msg.index('e'))
print(msg.index('egon'))
找不到
print(msg.find('xxx')) # 返回-1，代表找不到
print(msg.index('xxx')) # 抛出异常

msg='hello egon hahaha egon、 egon'
print(msg.count('egon'))

4.3.2、center,ljust,rjust,zfill
print('egon'.center(50,'*'))
print('egon'.ljust(50,'*'))
print('egon'.rjust(50,'*'))
print('egon'.zfill(10))

4.3.3、expandtabs
msg='hello\tworld'
print(msg.expandtabs(2)) # 设置制表符代表的空格数为2

4.3.4、captalize,swapcase,title
print("hello world egon".capitalize())
print("Hello WorLd EGon".swapcase())
print("hello world egon".title())

4.3.5、is数字系列
4.3.6、is其他
print('abc'.islower())
print('ABC'.isupper())
print('Hello World'.istitle())
print('123123aadsf'.isalnum()) # 字符串由字母或数字组成结果为True
print('ad'.isalpha()) # 字符串由由字母组成结果为True
print('     '.isspace()) # 字符串由空格组成结果为True
print('print'.isidentifier())
print('age_of_egon'.isidentifier())
print('1age_of_egon'.isidentifier())

num1=b'4' #bytes
num2=u'4' #unicode,python3中无需加u就是unicode
num3='四' #中文数字
num4='Ⅳ' #罗马数字

isdigit只能识别：num1、num2
print(num1.isdigit()) # True
print(num2.isdigit()) # True
print(num3.isdigit()) # False
print(num4.isdigit()) # False

isnumberic可以识别：num2、num3、num4
print(num2.isnumeric()) # True
print(num3.isnumeric()) # True
print(num4.isnumeric()) # True

isdecimal只能识别：num2
print(num2.isdecimal()) # True
print(num3.isdecimal()) # False
print(num4.isdecimal()) # False
```

1. 列表类型

```python
1、作用：按位置存放多个值
2、定义
l=[1,1.2,'a.txt'] # l=list([1,1.2,'a.txt'])
print(type(l))

3、类型转换: 但凡能够被for循环遍历的类型都可以当做参数传给list()转成列表
res=list('hello')
print(res)

res=list({'k1':111,'k2':222,'k3':3333})
print(res)

4、内置方法
优先掌握的操作：
1、按索引存取值(正向存取+反向存取)：即可以取也可以改
l=[111,'egon','hello']
正向取
print(l[0])
反向取
print(l[-1])
可以取也可以改：索引存在则修改对应的值
l[0]=222
print(l)

无论是取值操作还是赋值操作：索引不存在则报错
l[3]=333

2、切片(顾头不顾尾，步长)
# l = [111, 'egon', 'hello', 'a.txt', 'b', 'c', 'd', [1, 2, 3]]
print(l[0:3])
print(l[0:5:2]) # 0 2 4

print(l[0:len(l)])
print(l[:])
new_l=l[:] # 切片等同于拷贝行为，而且相当于浅copy
print(id(l))
print(id(new_l))

l[-1][0]=1111111
print(l)
print(new_l)

print(l[::-1])

msg1='hello:egon:<>:18[]==123'
msg2=msg1[:]
print(msg1,id(msg1))
print(msg2,id(msg2))
3、长度
print(len([1, 2, 3]))
4、成员运算in和not in
print('aaa.txt' in ['aaa.txt', 1, 2])
print(1 in ['aaa.txt', 1, 2])
5、往列表中添加值
5.1 追加
l=[111,'egon','hello']
l.append(3333)
l.append(4444)
print(l)

5.2、插入值
l=[111,'egon','hello']
l.insert(0,'alex')
print(l)

5.3、extend添加值
new_l=[1,2,3]
l=[111,'egon','hello']
l.append(new_l)
print(l)

代码实现
for item in new_l:
    l.append(item)
print(l)

extend实现了上述代码
l.extend(new_l)
l.extend('abc')
print(l)

7、删除
方式一：通用的删除方法，只是单纯的删除、没有返回值
l = [111, 'egon', 'hello']
del l[1]
x =del l[1] # 抛出异常，不支持赋值语法
print(l)

方式二：l.pop()根据索引删除，会返回删除的值
l = [111, 'egon', 'hello']
l.pop() # 不指定索引默认删除最后一个
l.pop()
print(l)

res=l.pop(1)
print(l)

print(res)

方式三：l.remove()根据元素删除，返回None
l = [111, 'egon', [1,2,3],'hello']
l.remove([1,2,3])
print(l)
res=l.remove('egon')
print(res) # None

8、循环
l=[1,'aaa.txt','bbb']
for x in l:
    l.pop(1)
    print(x)

需要掌握操作
# l = [1, 'aaa.txt', 'bbb','aaa.txt','aaa.txt']
1、l.count()
print(l.count('aaa.txt'))

2、l.index()
print(l.index('aaa.txt'))
print(l.index('aaaaaaaaa')) # 找不到报错

3、l.clear()
l.clear()
print(l)

4、l.reverse():不是排序，就是将列表倒过来
l = [1, 'egon','alex','lxx']
l.reverse()
print(l)

5、l.sort(): 列表内元素必须是同种类型才可以排序
l=[11,-3,9,2,3.1]
l.sort() # 默认从小到大排，称之为升序
l.sort(reverse=True) # 从大到小排，设置为降序
print(l)

l=[11,'a.txt',12]
l.sort()

l=['c','e','a.txt']
l.sort()
print(l)

了解：字符串可以比大小，按照对应的位置的字符依次pk
字符串的大小是按照ASCI码表的先后顺序加以区别，表中排在后面的字符大于前面的
print('a.txt'>'b')
print('abz'>'abcdefg')

了解：列表也可以比大小,原理同字符串一样,但是对应位置的元素必须是同种类型
l1=[1,'abc','zaa']
l2=[1,'abc','zb']

print(l1 < l2)

补充
1、队列：FIFO,先进先出
l=[]
# 入队操作
l.append('first')
l.append('second')
l.append('third')

print(l)
# 出队操作
print(l.pop(0))
print(l.pop(0))
print(l.pop(0))

2、堆栈：LIFO,后进先出
# l=[]
入栈操作
# l.append('first')
# l.append('second')
# l.append('third')

# print(l)
出队操作
# print(l.pop())
# print(l.pop())
# print(l.pop())
```

1. 元组类型

```python
元组就是"一个不可变的列表"
1、作用：按照索引/位置存放多个值，只用于读不用于改

2、定义:（）内用逗号分隔开多个任意类型的元素
t=(1,1.3,'aa') # t=tuple((1,1.3,'aa'))
print(t,type(t))

x=(10) # 单独一个括号代表包含的意思
print(x,type(x))

t=(10,) # 如果元组中只有一个元素，必须加逗号
print(t,type(t))

t=(1,1.3,'aa') # t=(0->值1的内存地址,1->值1.3的内存地址,2->值'aaa.txt'的内存地址，)
t[0]=11111

t=(1,[11,22]) # t=(0->值1的内存地址,1->值[1,2]的内存地址，)
print(id(t[0]),id(t[1]))
# t[0]=111111111 # 不能改
# t[1]=222222222 # 不能改

t[1][0]=11111111111111111
# print(t)
print(id(t[0]),id(t[1]))

3、类型转换
print(tuple('hello'))
print(tuple([1,2,3]))
print(tuple({'a1':111,'a2':333}))

4、内置方法
优先掌握的操作：
1、按索引取值(正向取+反向取)：只能取
t=('aa','bbb','cc')
print(t[0])
print(t[-1])

2、切片(顾头不顾尾，步长)
t=('aa','bbb','cc','dd','eee')
print(t[0:3])
print(t[::-1])

3、长度
t=('aa','bbb','cc','dd','eee')
print(len(t))
4、成员运算in和not in
print('aa' in t)

5、循环
for x in t:
    print(x)

6、
# t=(2,3,111,111,111,111)
print(t.index(111))
print(t.index(1111111111))

# print(t.count(111))
```

1. 字典类型

```python
1、作用

2、定义：{}内用逗号分隔开多个key：value，其中value可以使任意类型，但是
                                  key必须是不可变类型,且不能重复
造字典的方式一：
d={'k1':111,(1,2,3):222} # d=dict(...)
print(d['k1'])
print(d[(1,2,3)])
print(type(d))

d={} # 默认定义出来的是空字典
print(d,type(d))

造字典的方式二：
d=dict(x=1,y=2,z=3)
print(d,type(d))

3、数据类型转换
info=[
    ['name','egon'],
    ('age',18),
    ['gender','male']
]
# d={}
# for k,v in info: # k,v=['name','egon'],
#     d[k]=v
# print(d)

造字典的方式三：
res=dict(info) # 一行代码搞定上述for循环的工作
print(res)

造字典的方式四:快速初始化一个字典
keys=['name','age','gender']
# d={}
# for k in keys:
#     d[k]=None
# print(d)
d={}.fromkeys(keys,None) # 一行代码搞定上述for循环的工作
print(d)

4、内置方法
优先掌握的操作：
1、按key存取值：可存可取
d={'k1':111}
针对赋值操作：key存在，则修改
d['k1']=222
针对赋值操作：key不存在，则创建新值
d['k2']=3333
print(d)

2、长度len
d={'k1':111,'k2':2222,'k1':3333,'k1':4444}
print(d)
print(len(d))

3、成员运算in和not in:根据key
d={'k1':111,'k2':2222}
print('k1' in d)
print(111 in d)

4、删除
# d={'k1':111,'k2':2222}
4.1 通用删除
del d['k1']
print(d)

4.2 pop删除：根据key删除元素，返回删除key对应的那个value值
res=d.pop('k2')
print(d)
print(res)

4.3 popitem删除：随机删除，返回元组(删除的key,删除的value)
res=d.popitem()
print(d)
print(res)

5、键keys()，值values()，键值对items()  =>在python3中得到的是老母鸡
# d={'k1':111,'k2':2222}
# '''
# 在python2中
# >>> d={'k1':111,'k2':2222}
# >>> 
# >>> d.keys()#6、循环
# ['k2', 'k1']
# >>> d.values()
# [2222, 111]
# >>> d.items()
# [('k2', 2222), ('k1', 111)]
# >>> dict(d.items())
# {'k2': 2222, 'k1': 111}
# >>>
# '''  

6、for循环
for k in d.keys():
    print(k)

for k in d:
    print(k)

for v in d.values():
    print(v)

for k,v in d.items():
    print(k,v)

print(list(d.keys()))
print(list(d.values()))
print(list(d.items()))

需要掌握的内置方法
# d={'k1':111}
1、d.clear()

2、d.update()
d.update({'k2':222,'k3':333,'k1':111111111111111})
print(d)

3、d.get() ：根据key取值，容错性好
print(d['k2'])  # key不存在则报错

print(d.get('k1')) # 111
print(d.get('k2')) # key不存在不报错，返回None

4、d.setdefault()
info={}
if 'name' in info:
    ... # 等同于pass
else:
    info['name']='egon'
print(info)

4.1 如果key有则不添加,返回字典中key对应的值
# info={'name':'egon'}
# res=info.setdefault('name','egon')
print(info)

# print(res)

4.2 如果key没有则添加，返回字典中key对应的值
# info={}
# res=info.setdefault('name','egon')
print(info)
# print(res)
```

1. 集合类型

```python
1、作用
1.1 关系运算
friends1 = ["zero","kevin","jason","egon"]
friends2 = ["Jy","ricky","jason","egon"]

l=[]
for x in friends1:
    if x in friends2:
        l.append(x)
print(l)

1.2、去重

2、定义: 在{}内用逗号分隔开多个元素，多个元素满足以下三个条件
           1. 集合内元素必须为不可变类型
           2. 集合内元素无序
           3. 集合内元素没有重复

s={1,2} # s=set({1,2})

s={1,[1,2]} # 集合内元素必须为不可变类型
s={1,'a.txt','z','b',4,7} # 集合内元素无序
s={1,1,1,1,1,1,'a.txt','b'} # 集合内元素没有重复
print(s)

了解
s={} # 默认是空字典
print(type(s))
定义空集合
s=set()
print(s,type(s))

3、类型转换
set({1,2,3})
res=set('hellolllll')
print(res)

print(set([1,1,1,1,1,1]))
print(set([1,1,1,1,1,1,[11,222]]) # 报错

print(set({'k1':1,'k2':2}))

4、内置方法
=========================关系运算符=========================
# friends1 = {"zero","kevin","jason","egon"}
# friends2 = {"Jy","ricky","jason","egon"}

4.1 取交集：两者共同的好友
res=friends1 & friends2
print(res)
print(friends1.intersection(friends2))
4.2 取并集/合集：两者所有的好友
print(friends1 | friends2)
print(friends1.union(friends2))

4.3 取差集：取friends1独有的好友
print(friends1 - friends2)
print(friends1.difference(friends2))

取friends2独有的好友
print(friends2 - friends1)
print(friends2.difference(friends1))

4.4 对称差集: 求两个用户独有的好友们（即去掉共有的好友）
print(friends1 ^ friends2)
print(friends1.symmetric_difference(friends2))

4.5 父子集：包含的关系
s1={1,2,3}
s2={1,2,4}
不存在包含关系，下面比较均为False
print(s1 > s2)
print(s1 < s2)

s1={1,2,3}
s2={1,2}
print(s1 > s2) # 当s1大于或等于s2时，才能说是s1是s2他爹
print(s1.issuperset(s2))
print(s2.issubset(s1)) # s2 < s2  =>True

s1={1,2,3}
s2={1,2,3}
print(s1 == s2) # s1与s2互为父子
print(s1.issuperset(s2))
print(s2.issuperset(s1))

=========================去重=========================
1、只能针对不可变类型去重
print(set([1,1,1,1,2]))

2、无法保证原来的顺序
l=[1,'a.txt','b','z',1,1,1,2]
l=list(set(l))
print(l)

# l=[
    # {'name':'lili','age':18,'sex':'male'},
    # {'name':'jack','age':73,'sex':'male'},
    # {'name':'tom','age':20,'sex':'female'},
    # {'name':'lili','age':18,'sex':'male'},
    # {'name':'lili','age':18,'sex':'male'},
# ]
# new_l=[]
# for dic in l:
    # if dic not in new_l:
        # new_l.append(dic)

print(new_l)

其他操作
# '''
1.长度
# >>> s={'a.txt','b','c'}
# >>> len(s)
# 3

2.成员运算
# >>> 'c' in s
# True

3.循环
# >>> for item in s:
# ...     print(item)
# ... 
# c
# a.txt
# b
# '''

其他内置方法
# s={1,2,3}
需要掌握的内置方法1：discard
s.discard(4) # 删除元素不存在do nothing
print(s)
s.remove(4) # 删除元素不存在则报错

需要掌握的内置方法2：update
s.update({1,3,5})
print(s)

需要掌握的内置方法3：pop
res=s.pop()
print(res)

需要掌握的内置方法4：add
s.add(4)
print(s)

其余方法全为了解
# res=s.isdisjoint({3,4,5,6}) # 两个集合完全独立、没有共同部分，返回True
# print(res)

了解
s.difference_update({3,4,5}) # s=s.difference({3,4,5})
print(s)
```

1. 字符编码与解码

```python
分析过程

x="上"

                    内存
上-------翻译-----》0101010
上《----翻译《-----0101010

字符编码表就是一张字符与数字对应关系的表

a-00
b-01
c-10
d-11

ASCII表：
    1、只支持英文字符串
    2、采用8位二进制数对应一个英文字符串

GBK表：
    1、支持英文字符、中文字符
    2、
    采用8位（8bit=1Bytes）二进制数对应一个英文字符串
    采用16位（16bit=2Bytes）二进制数对应一个中文字符串

unicode（内存中统一使用unicode）：
    1、
        兼容万国字符
        与万国字符都有对应关系
    2、
    采用16位（16bit=2Bytes）二进制数对应一个中文字符串
    个别生僻会采用4Bytes、8Bytes

    unicode表：
                          内存
        人类的字符---------unicode格式的数字----------
                             |                     |
                             |                     |
                             |
                            硬盘                    |
                             |
                             |                     |
                             |                     |
                        GBK格式的二进制       Shift-JIS格式的二进制

        老的字符编码都可以转换成unicode，但是不能通过unicode互转

utf-8：
    英文->1Bytes
    汉字->3Bytes

结论：
    1、内存固定使用unicode，我们可以改变的是存入硬盘采用格式
        英文+汉字-》unicode-》gbk
        英文+日文-》unicode-》shift-jis
        万国字符》-unicode-》utf-8

    2、文本文件存取乱码问题
        存乱了：解决方法是，编码格式应该设置成支持文件内字符串的格式
        取乱了：解决方法是，文件是以什么编码格式存如硬盘的，就应该以什么编码格式读入内存

    3、python解释器默认读文件的编码
        python3默认：utf-8
        python2默认：ASCII

        指定文件头修改默认的编码：
        在py文件的首行写：
            #coding:gbk

     4、保证运行python程序前两个阶段不乱码的核心法则：
        指定文件头
        # coding:文件当初存入硬盘时所采用的编码格式

     5、
        python3的str类型默认直接存成unicode格式，无论如何都不会乱码
        保证python2的str类型不乱码
            x=u'上'

    6、了解
        python2解释器有两种字符串类型：str、unicode
            # str类型
            x='上' # 字符串值会按照文件头指定的编码格式存入变量值的内存空间
            # unicode类型
            x=u'上' # 强制存成unicode

#编码解码代码示例
# coding:utf-8
x='上'

res=x.encode('gbk') # unicode--->gbk
print(res,type(res))

print(res.decode('gbk'))
```

## 进制转换

```python
class Solution:
		def countBits(self, n: int) -> List[int]:
				res = [0]*(n+1)
				for i in range(n+1):
						res[i] = bin(i).replace('0b','').count('1')
		return res
```

- 二进制赋值以0b打头
    
    a = 0b1000
    
- 八进制赋值以0o打头，第一个是数字0第二个是字母o
    
    b = 0o1100
    
- 十进制不需要特别标明
    
    c = 1110
    
- 十六进制赋值以0x打头
    
    d = 0x1111
    
- **2/8/10/16进制互转**
    - 十进制转二进制----bin(var)
    - 十进制转八进制----oct(var)
    - 十进制转十六进制----hex(var)
    - 其他进制转十进制----int(var,base=10),具体的进制数，基于base值
        - base 默认是 10，还可以取 0 以及 2 到 36，不能是 1，因为没有 1 进制
        - base 为 **0 的时候会按照代码字面量（code literal）解析(也就是按照字面给的格式)**，即只能把 2、8、10、16 进制数字表示转换为 10 进制。对于 2、8、16 进制必须指明相应进制的前缀，否则会按照 10 进制解析
        - 当base=2时，无论数据为‘0b110’还是‘110’，都会按照二进制转为10进制，但是当base=0时，‘110’只会按照十进制来解析,其他进制数同理
- **字符和ASCII编码转换**
    - 用户输入字符 c = input("请输入一个字符: ")
    - 用户输入ASCII码，并将输入的数字转为整型 a = int(input("请输入一个ASCII码: "))
    - print( c + " 的ASCII 码为", **ord**(c))
    - print( a , " 对应的字符为", **chr**(a))
- **format的格式应用**
    
    [docs.python.org](https://docs.python.org/3/library/string.html#formatspec)
    

![Untitled](%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%20bc54299782774d438f5875e85a98a662/Untitled.png)

![Untitled](%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%20bc54299782774d438f5875e85a98a662/Untitled%201.png)